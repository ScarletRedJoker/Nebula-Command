#!/bin/bash
# ╔════════════════════════════════════════════════════════════════╗
# ║              HOMELAB - Simple, Unified Management              ║
# ╚════════════════════════════════════════════════════════════════╝
# Philosophy: Simple, straightforward, automated, self-healing
#
# Usage:
#   ./homelab up       - Start all services
#   ./homelab down     - Stop all services
#   ./homelab status   - Show service status
#   ./homelab logs     - View logs
#   ./homelab fix      - Rebuild and restart everything
#   ./homelab health   - Run health checks
#   ./homelab restart  - Restart all services

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# Auto-detect project root
# Priority: 1) Script directory, 2) /opt/homelab, 3) /home/evin, 4) pwd
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

if [ -f "$SCRIPT_DIR/.env" ] || [ -f "$SCRIPT_DIR/docker-compose.yml" ] || [ -f "$SCRIPT_DIR/compose.local.yml" ]; then
    PROJECT_ROOT="$SCRIPT_DIR"
elif [ -d "/opt/homelab/HomeLabHub" ] && [ -f "/opt/homelab/HomeLabHub/.env" -o -f "/opt/homelab/HomeLabHub/docker-compose.yml" ]; then
    PROJECT_ROOT="/opt/homelab/HomeLabHub"
elif [ -d "/home/evin/contain/HomeLabHub" ] && [ -f "/home/evin/contain/HomeLabHub/.env" -o -f "/home/evin/contain/HomeLabHub/compose.local.yml" ]; then
    PROJECT_ROOT="/home/evin/contain/HomeLabHub"
else
    PROJECT_ROOT="$SCRIPT_DIR"
fi

# Auto-detect role: local (Ubuntu host) vs cloud (Linode)
# Priority: 1) HOMELAB_ROLE env var, 2) --role flag, 3) auto-detect
detect_role() {
    # Check environment variable first
    if [ -n "${HOMELAB_ROLE:-}" ]; then
        echo "$HOMELAB_ROLE"
        return
    fi
    
    # Auto-detect based on available compose files and hostname
    if [ -f "$PROJECT_ROOT/compose.local.yml" ] && [ ! -f "$PROJECT_ROOT/docker-compose.yml" ]; then
        echo "local"
    elif hostname | grep -qi "linode\|localhost" && [ -f "$PROJECT_ROOT/docker-compose.yml" ]; then
        echo "cloud"
    elif [ -f "$PROJECT_ROOT/compose.local.yml" ] && [ -d "/home/evin" ]; then
        # Ubuntu host with local compose file
        echo "local"
    else
        echo "cloud"
    fi
}

ROLE="${HOMELAB_ROLE:-$(detect_role)}"

# Configure based on role
if [ "$ROLE" = "local" ]; then
    ENV_FILE="$PROJECT_ROOT/.env"
    COMPOSE_FILE="$PROJECT_ROOT/compose.local.yml"
    ALL_SERVICES=("plex-server" "homeassistant" "homelab-minio" "sunshine-gamestream")
    TOTAL_SERVICES=4
    ROLE_NAME="Local (Ubuntu Host)"
else
    # Cloud deployment uses deploy/linode/.env for secrets
    if [ -f "$PROJECT_ROOT/deploy/linode/.env" ]; then
        ENV_FILE="$PROJECT_ROOT/deploy/linode/.env"
    elif [ -f "$PROJECT_ROOT/.env" ]; then
        ENV_FILE="$PROJECT_ROOT/.env"
    else
        ENV_FILE="$PROJECT_ROOT/deploy/linode/.env"
    fi
    COMPOSE_FILE="$PROJECT_ROOT/docker-compose.yml"
    ALL_SERVICES=(
        "homelab-postgres" "homelab-redis"
        "homelab-dashboard" "homelab-celery-worker"
        "discord-bot" "stream-bot"
        "caddy" "code-server" "code-server-proxy"
        "n8n"
        "rig-city-site" "scarletredjoker-web"
    )
    TOTAL_SERVICES=12
    ROLE_NAME="Cloud (Linode)"
fi

# Verify files exist
if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}ERROR: .env file not found at $ENV_FILE${NC}"
    echo ""
    echo "Quick setup:"
    if [ "$ROLE" = "cloud" ]; then
        echo "  cd $PROJECT_ROOT/deploy/linode"
        echo "  cp .env.example .env"
        echo "  nano .env  # Update your credentials"
    else
        echo "  cp .env.example .env"
        echo "  nano .env  # Update your credentials"
    fi
    echo ""
    exit 1
fi

if [ ! -f "$COMPOSE_FILE" ]; then
    echo -e "${RED}ERROR: Compose file not found: $COMPOSE_FILE${NC}"
    echo "Role: $ROLE"
    echo ""
    echo "Make sure you have the correct compose file for your role."
    exit 1
fi

# Docker Compose wrapper - simple and direct
compose() {
    docker compose \
        --project-directory "$PROJECT_ROOT" \
        --env-file "$ENV_FILE" \
        -f "$COMPOSE_FILE" \
        "$@"
}

# Check if service is running
is_running() {
    docker ps --format "{{.Names}}" | grep -q "^$1$"
}

# Count running services
count_running() {
    local count=0
    for service in "${ALL_SERVICES[@]}"; do
        is_running "$service" && ((count++))
    done
    echo $count
}

# ============================================
# FIX COMMAND - Simple and Effective
# ============================================
fix() {
    echo -e "${CYAN}═══ FIXING HOMELAB ═══${NC}\n"
    
    echo "Project: $PROJECT_ROOT"
    echo "Env File: $ENV_FILE"
    echo ""
    
    # Rebuild bots with --no-cache to pick up password changes
    echo -e "${CYAN}[1/4] Rebuilding bots without cache (ensures password changes are applied)...${NC}"
    compose build --no-cache discord-bot stream-bot
    
    # Force recreate ALL containers with correct environment
    echo -e "${CYAN}[2/4] Force recreating all services with environment...${NC}"
    compose up -d --force-recreate
    
    echo -e "${CYAN}[3/4] Waiting for stability...${NC}"
    sleep 10
    
    # Create databases if PostgreSQL is ready
    echo -e "${CYAN}[4/4] Setting up databases...${NC}"
    if docker exec homelab-postgres pg_isready -U postgres &>/dev/null; then
        for db in ticketbot streambot homelab_jarvis; do
            if ! docker exec homelab-postgres psql -U postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw "$db"; then
                echo "  Creating database: $db"
                docker exec homelab-postgres psql -U postgres -c "CREATE DATABASE $db;" 2>/dev/null || true
            fi
        done
        echo -e "${GREEN}✓ Databases ready${NC}"
    fi
    
    # Status
    local running=$(count_running)
    echo ""
    if [ $running -eq $TOTAL_SERVICES ]; then
        echo -e "${GREEN}✅ SUCCESS! All $TOTAL_SERVICES/$TOTAL_SERVICES services running!${NC}"
    else
        echo -e "${YELLOW}⚠ $running/$TOTAL_SERVICES services running${NC}"
        echo "Check logs: ./homelab logs"
    fi
}

# ============================================
# STATUS COMMAND
# ============================================
status() {
    echo -e "\n${CYAN}═══ Service Status ═══${NC}"
    echo -e "Role: ${YELLOW}$ROLE_NAME${NC}\n"
    
    local running=0
    for service in "${ALL_SERVICES[@]}"; do
        if is_running "$service"; then
            echo -e "$service: ${GREEN}● Running${NC}"
            ((running++))
        else
            echo -e "$service: ${RED}○ Stopped${NC}"
        fi
    done
    
    echo ""
    if [ $running -eq $TOTAL_SERVICES ]; then
        echo -e "${GREEN}✅ All $TOTAL_SERVICES/$TOTAL_SERVICES services running${NC}"
    else
        echo -e "${YELLOW}⚠ $running/$TOTAL_SERVICES services running${NC}"
    fi
}

# ============================================
# LOGS COMMAND with Auto-Save and JSON Support
# ============================================
logs() {
    mkdir -p "$PROJECT_ROOT/logs"
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local json_mode=false
    local service=""
    local tail_lines=100
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json|-j)
                json_mode=true
                shift
                ;;
            --tail|-n)
                tail_lines="$2"
                shift 2
                ;;
            --tail=*)
                tail_lines="${1#*=}"
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: ./homelab logs [--json] [--tail N] [service]"
                return 1
                ;;
            *)
                service="$1"
                shift
                ;;
        esac
    done
    
    if $json_mode; then
        # JSON output mode - structured logs for automation
        echo -e "${CYAN}Outputting logs in JSON format...${NC}" >&2
        
        local json_log_file="$PROJECT_ROOT/logs/json-${service:-all}-$timestamp.json"
        
        if [ -z "$service" ]; then
            # All services - JSON format
            compose logs --tail="$tail_lines" --no-color 2>/dev/null | while IFS= read -r line; do
                # Parse docker compose log format: container-name | message
                local container=$(echo "$line" | cut -d'|' -f1 | xargs 2>/dev/null || echo "unknown")
                local message=$(echo "$line" | cut -d'|' -f2- | sed 's/^ //')
                local level="INFO"
                
                # Detect log level from content
                if echo "$line" | grep -qiE '\b(error|exception|fail|fatal)\b'; then
                    level="ERROR"
                elif echo "$line" | grep -qiE '\b(warn|warning)\b'; then
                    level="WARN"
                elif echo "$line" | grep -qiE '\b(debug)\b'; then
                    level="DEBUG"
                fi
                
                # Escape special characters for JSON
                message=$(echo "$message" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | tr -d '\n\r')
                
                echo "{\"timestamp\":\"$(date -Iseconds)\",\"level\":\"$level\",\"service\":\"$container\",\"message\":\"$message\"}"
            done | tee "$json_log_file"
        else
            # Specific service - JSON format
            compose logs --tail="$tail_lines" --no-color "$service" 2>/dev/null | while IFS= read -r line; do
                local message=$(echo "$line" | cut -d'|' -f2- | sed 's/^ //' || echo "$line")
                local level="INFO"
                
                if echo "$line" | grep -qiE '\b(error|exception|fail|fatal)\b'; then
                    level="ERROR"
                elif echo "$line" | grep -qiE '\b(warn|warning)\b'; then
                    level="WARN"
                elif echo "$line" | grep -qiE '\b(debug)\b'; then
                    level="DEBUG"
                fi
                
                message=$(echo "$message" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | tr -d '\n\r')
                
                echo "{\"timestamp\":\"$(date -Iseconds)\",\"level\":\"$level\",\"service\":\"$service\",\"message\":\"$message\"}"
            done | tee "$json_log_file"
        fi
        
        echo "" >&2
        echo -e "${GREEN}JSON logs saved to: $json_log_file${NC}" >&2
    else
        # Standard output mode
        if [ -z "$service" ]; then
            echo -e "${CYAN}Showing logs for all services...${NC}"
            compose logs --tail="$tail_lines" -f | tee "$PROJECT_ROOT/logs/all-services-$timestamp.log"
        else
            echo -e "${CYAN}Showing logs for $service...${NC}"
            compose logs --tail="$tail_lines" -f "$service" | tee "$PROJECT_ROOT/logs/$service-$timestamp.log"
        fi
    fi
}

# ============================================
# DEBUG COMMAND - Show What Docker Sees
# ============================================
debug() {
    echo -e "${CYAN}═══ Debug Information ═══${NC}\n"
    
    echo "Project Root: $PROJECT_ROOT"
    echo "Current Dir: $(pwd)"
    echo ""
    
    echo -e "${CYAN}Checking .env file:${NC}"
    if [ -f "$ENV_FILE" ]; then
        echo -e "${GREEN}✓ .env exists${NC}"
        echo "  Variables loaded:"
        grep -c "=" "$ENV_FILE" | xargs echo "  "
        echo ""
        echo "  Checking critical variables:"
        grep "^WEB_USERNAME=" "$ENV_FILE" || echo -e "  ${RED}✗ WEB_USERNAME missing${NC}"
        grep "^WEB_PASSWORD=" "$ENV_FILE" || echo -e "  ${RED}✗ WEB_PASSWORD missing${NC}"
        grep "^POSTGRES_PASSWORD=" "$ENV_FILE" || echo -e "  ${RED}✗ POSTGRES_PASSWORD missing${NC}"
    else
        echo -e "${RED}✗ .env NOT FOUND${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}Checking homelab-dashboard container environment:${NC}"
    if is_running "homelab-dashboard"; then
        echo "  WEB_USERNAME in container:"
        docker exec homelab-dashboard env | grep "WEB_USERNAME" || echo -e "  ${RED}✗ NOT SET${NC}"
        echo "  POSTGRES_PASSWORD in container:"
        docker exec homelab-dashboard env | grep "POSTGRES_PASSWORD" || echo -e "  ${RED}✗ NOT SET${NC}"
    else
        echo -e "${YELLOW}  Dashboard not running${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}Service Status:${NC}"
    status
}

# ============================================
# HEALTH COMMAND - Comprehensive Health Checks
# ============================================
health() {
    local use_doctor=false
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full|--doctor|-d)
                use_doctor=true
                shift
                ;;
            --json|-j)
                json_output=true
                use_doctor=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # If doctor mode or JSON output requested, use the doctor script
    if $use_doctor; then
        if [ -f "$PROJECT_ROOT/homelab-doctor.sh" ]; then
            if $json_output; then
                "$PROJECT_ROOT/homelab-doctor.sh" json
            else
                "$PROJECT_ROOT/homelab-doctor.sh" human
            fi
            return $?
        else
            echo -e "${YELLOW}⚠ homelab-doctor.sh not found, running basic health check${NC}"
        fi
    fi
    
    echo -e "\n${CYAN}═══ Comprehensive Health Check ═══${NC}\n"
    echo "Tip: Use './homelab health --full' for comprehensive diagnostics"
    echo "     Use './homelab health --json' for JSON output"
    echo ""
    
    local health_issues=0
    
    # 1. Database Connectivity
    echo -e "${CYAN}[1/5] Database Connections${NC}"
    if is_running "homelab-postgres"; then
        if docker exec homelab-postgres pg_isready -U postgres &>/dev/null; then
            echo -e "  ${GREEN}✓${NC} PostgreSQL responding"
            
            # Check each database
            for db in ticketbot streambot homelab_jarvis; do
                if docker exec homelab-postgres psql -U postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw "$db"; then
                    echo -e "  ${GREEN}✓${NC} Database: $db"
                else
                    echo -e "  ${RED}✗${NC} Database missing: $db"
                    ((health_issues++))
                fi
            done
        else
            echo -e "  ${RED}✗${NC} PostgreSQL not responding"
            ((health_issues++))
        fi
    else
        echo -e "  ${RED}✗${NC} PostgreSQL container not running"
        ((health_issues++))
    fi
    
    # 2. API Endpoint Tests
    echo -e "\n${CYAN}[2/5] API Endpoints${NC}"
    test_endpoint() {
        local name=$1
        local url=$2
        local expected_codes=$3
        
        local status=$(curl -s -o /dev/null -w "%{http_code}" "$url" 2>/dev/null || echo "000")
        if echo "$expected_codes" | grep -q "$status"; then
            echo -e "  ${GREEN}✓${NC} $name (HTTP $status)"
        else
            echo -e "  ${RED}✗${NC} $name (HTTP $status, expected: $expected_codes)"
            ((health_issues++))
        fi
    }
    
    test_endpoint "Dashboard" "http://localhost:8080/" "200 302"
    test_endpoint "Discord Bot" "http://localhost:4000/health" "200 302 404"
    test_endpoint "Stream Bot" "http://localhost:5000/health" "200 302 404"
    test_endpoint "MinIO" "http://localhost:9000/minio/health/live" "200"
    
    # 3. Disk Space
    echo -e "\n${CYAN}[3/5] Disk Space${NC}"
    local disk_usage=$(df -h "$PROJECT_ROOT" | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ "$disk_usage" -lt 80 ]; then
        echo -e "  ${GREEN}✓${NC} Disk usage: ${disk_usage}%"
    elif [ "$disk_usage" -lt 90 ]; then
        echo -e "  ${YELLOW}⚠${NC} Disk usage: ${disk_usage}% (warning)"
        ((health_issues++))
    else
        echo -e "  ${RED}✗${NC} Disk usage: ${disk_usage}% (critical)"
        ((health_issues++))
    fi
    
    # 4. Memory Usage
    echo -e "\n${CYAN}[4/5] Memory Usage${NC}"
    local mem_available=$(free -m | awk 'NR==2 {print $7}')
    local mem_total=$(free -m | awk 'NR==2 {print $2}')
    local mem_percent=$((100 - (mem_available * 100 / mem_total)))
    
    if [ "$mem_percent" -lt 80 ]; then
        echo -e "  ${GREEN}✓${NC} Memory usage: ${mem_percent}%"
    elif [ "$mem_percent" -lt 90 ]; then
        echo -e "  ${YELLOW}⚠${NC} Memory usage: ${mem_percent}% (warning)"
    else
        echo -e "  ${RED}✗${NC} Memory usage: ${mem_percent}% (critical)"
        ((health_issues++))
    fi
    
    # 5. Container Health Status
    echo -e "\n${CYAN}[5/5] Container Health Status${NC}"
    for service in "${ALL_SERVICES[@]}"; do
        if is_running "$service"; then
            local health_status=$(docker inspect "$service" --format='{{.State.Health.Status}}' 2>/dev/null || echo "no-healthcheck")
            if [ "$health_status" = "healthy" ] || [ "$health_status" = "no-healthcheck" ]; then
                echo -e "  ${GREEN}✓${NC} $service"
            elif [ "$health_status" = "starting" ]; then
                echo -e "  ${YELLOW}⟳${NC} $service (starting)"
            else
                echo -e "  ${RED}✗${NC} $service ($health_status)"
                ((health_issues++))
            fi
        else
            echo -e "  ${RED}○${NC} $service (not running)"
            ((health_issues++))
        fi
    done
    
    # Summary
    echo ""
    if [ $health_issues -eq 0 ]; then
        echo -e "${GREEN}✅ All health checks passed!${NC}"
        return 0
    else
        echo -e "${RED}⚠ Found $health_issues health issue(s)${NC}"
        echo "Run './homelab fix' to attempt automatic repair"
        return 1
    fi
}

# ============================================
# VALIDATE-ENV COMMAND - Environment Validation
# ============================================
validate_env() {
    echo -e "\n${CYAN}═══ Environment Validation ═══${NC}\n"
    
    if [ ! -f "$ENV_FILE" ]; then
        echo -e "${RED}✗ .env file not found at $ENV_FILE${NC}"
        echo "Create it from template: cp .env.example .env"
        return 1
    fi
    
    echo "Checking required variables..."
    echo ""
    
    local required_vars=(
        "POSTGRES_PASSWORD"
        "DISCORD_DB_PASSWORD"
        "STREAMBOT_DB_PASSWORD"
        "JARVIS_DB_PASSWORD"
        "WEB_USERNAME"
        "WEB_PASSWORD"
        "SESSION_SECRET"
        "DISCORD_BOT_TOKEN"
        "DISCORD_CLIENT_ID"
        "DISCORD_CLIENT_SECRET"
        "OPENAI_API_KEY"
    )
    
    local missing_vars=()
    local present_vars=()
    
    for var in "${required_vars[@]}"; do
        if grep -q "^${var}=" "$ENV_FILE" && [ -n "$(grep "^${var}=" "$ENV_FILE" | cut -d'=' -f2)" ]; then
            echo -e "  ${GREEN}✓${NC} $var"
            present_vars+=("$var")
        else
            echo -e "  ${RED}✗${NC} $var - MISSING or EMPTY"
            missing_vars+=("$var")
        fi
    done
    
    echo ""
    echo "Summary: ${#present_vars[@]}/${#required_vars[@]} required variables present"
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        echo ""
        echo -e "${RED}Missing variables:${NC}"
        for var in "${missing_vars[@]}"; do
            echo "  - $var"
        done
        echo ""
        echo "Update your .env file before deployment"
        return 1
    else
        echo -e "\n${GREEN}✅ All required variables present${NC}"
        return 0
    fi
}

# ============================================
# BACKUP COMMAND - Database Backups with Full System Option
# ============================================
backup() {
    local full_backup=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full|-f)
                full_backup=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if $full_backup; then
        echo -e "\n${CYAN}═══ Full System Backup ═══${NC}\n"
    else
        echo -e "\n${CYAN}═══ Database Backup ═══${NC}\n"
    fi
    
    if ! is_running "homelab-postgres"; then
        echo -e "${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    # Create backups directory with secure permissions
    local backup_dir="$PROJECT_ROOT/backups"
    mkdir -p "$backup_dir"
    chmod 700 "$backup_dir"
    
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_file="$backup_dir/homelab-backup-$timestamp.sql"
    
    echo "Backing up databases to:"
    echo "  $backup_file"
    echo ""
    
    # Extract PostgreSQL password from .env (secure method)
    local POSTGRES_PASSWORD=$(grep "^POSTGRES_PASSWORD=" "$ENV_FILE" | cut -d'=' -f2-)
    
    if [ -z "$POSTGRES_PASSWORD" ]; then
        echo -e "${RED}✗ POSTGRES_PASSWORD not found in .env${NC}"
        return 1
    fi
    
    # Backup all databases using PGPASSWORD (no credentials in process list)
    if PGPASSWORD="$POSTGRES_PASSWORD" docker exec homelab-postgres \
        pg_dumpall -U postgres > "$backup_file"; then
        
        # Set secure permissions on backup file (owner read/write only)
        chmod 600 "$backup_file"
        
        local size=$(du -h "$backup_file" | cut -f1)
        echo -e "${GREEN}✅ Database backup created${NC}"
        echo "  Size: $size"
        echo "  File: $(basename $backup_file)"
        
        # Full backup - include configuration files
        if $full_backup; then
            echo ""
            echo -e "${CYAN}Creating full system backup (configs, compose files)...${NC}"
            
            local full_backup_dir="$backup_dir/full-$timestamp"
            mkdir -p "$full_backup_dir"
            chmod 700 "$full_backup_dir"
            
            # Copy database backup
            cp "$backup_file" "$full_backup_dir/"
            
            # Backup configuration files (exclude secrets from .env)
            if [ -f "$PROJECT_ROOT/.env" ]; then
                # Create sanitized .env backup (remove sensitive values)
                grep -v -E "PASSWORD|SECRET|TOKEN|KEY" "$PROJECT_ROOT/.env" > "$full_backup_dir/.env.sanitized" 2>/dev/null || true
                echo -e "  ${GREEN}✓${NC} .env (sanitized)"
            fi
            
            # Backup docker-compose files
            for compose_file in docker-compose.yml docker-compose.override.yml; do
                if [ -f "$PROJECT_ROOT/$compose_file" ]; then
                    cp "$PROJECT_ROOT/$compose_file" "$full_backup_dir/"
                    echo -e "  ${GREEN}✓${NC} $compose_file"
                fi
            done
            
            # Backup Caddyfile
            if [ -f "$PROJECT_ROOT/Caddyfile" ]; then
                cp "$PROJECT_ROOT/Caddyfile" "$full_backup_dir/"
                echo -e "  ${GREEN}✓${NC} Caddyfile"
            fi
            
            # Backup config directory (without secrets)
            if [ -d "$PROJECT_ROOT/config" ]; then
                mkdir -p "$full_backup_dir/config"
                find "$PROJECT_ROOT/config" -type f \( -name "*.json" -o -name "*.yml" -o -name "*.yaml" -o -name "*.conf" \) \
                    ! -name "*secret*" ! -name "*credentials*" -exec cp {} "$full_backup_dir/config/" \; 2>/dev/null || true
                echo -e "  ${GREEN}✓${NC} config/ directory"
            fi
            
            # Backup orchestration configs
            if [ -d "$PROJECT_ROOT/orchestration" ]; then
                mkdir -p "$full_backup_dir/orchestration"
                cp -r "$PROJECT_ROOT/orchestration/"*.yml "$full_backup_dir/orchestration/" 2>/dev/null || true
                cp -r "$PROJECT_ROOT/orchestration/"*.yaml "$full_backup_dir/orchestration/" 2>/dev/null || true
                echo -e "  ${GREEN}✓${NC} orchestration/ directory"
            fi
            
            # Create tarball
            local tarball="$backup_dir/homelab-full-$timestamp.tar.gz"
            tar -czf "$tarball" -C "$backup_dir" "full-$timestamp" 2>/dev/null
            chmod 600 "$tarball"
            rm -rf "$full_backup_dir"
            
            local tarball_size=$(du -h "$tarball" | cut -f1)
            echo ""
            echo -e "${GREEN}✅ Full system backup created${NC}"
            echo "  Database: $(basename $backup_file) ($size)"
            echo "  Full backup: $(basename $tarball) ($tarball_size)"
            echo ""
            echo "To restore:"
            echo "  1. Extract: tar -xzf $tarball"
            echo "  2. Restore DB: ./homelab restore $backup_file"
            echo "  3. Manually restore configs as needed"
        else
            echo "  Permissions: 600 (secure)"
            echo ""
            echo "To restore: ./homelab restore $backup_file"
            echo "For full backup (includes configs): ./homelab backup --full"
        fi
        
        # Keep only last 10 database backups
        cd "$backup_dir"
        ls -t homelab-backup-*.sql 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null
        # Keep only last 5 full backups
        ls -t homelab-full-*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null
        local backup_count=$(ls -1 homelab-backup-*.sql 2>/dev/null | wc -l)
        local full_count=$(ls -1 homelab-full-*.tar.gz 2>/dev/null | wc -l)
        echo ""
        echo "  Backups retained: $backup_count database, $full_count full"
        
        # Clear password from environment
        unset POSTGRES_PASSWORD
        return 0
    else
        echo -e "${RED}✗ Backup failed${NC}"
        rm -f "$backup_file"
        unset POSTGRES_PASSWORD
        return 1
    fi
}

# ============================================
# RESTORE COMMAND - Database Restore
# ============================================
restore() {
    local input_file="$1"
    
    # Whitelist: Only allow backups from secure directory
    local BACKUPS_DIR="$PROJECT_ROOT/backups"
    
    if [ -z "$input_file" ]; then
        echo -e "${RED}✗ Usage: ./homelab restore <backup-file>${NC}"
        echo ""
        echo "Available backups:"
        if [ -d "$BACKUPS_DIR" ]; then
            ls -1t "$BACKUPS_DIR/"homelab-backup-*.sql 2>/dev/null | head -5 | while read f; do
                echo "  $(basename $f) ($(du -h "$f" | cut -f1))"
            done
        else
            echo "  No backups found in $BACKUPS_DIR"
        fi
        return 1
    fi
    
    # Convert to absolute path for validation
    local backup_file
    if [[ "$input_file" = /* ]]; then
        backup_file="$input_file"
    else
        backup_file="$(cd "$(dirname "$input_file")" 2>/dev/null && pwd)/$(basename "$input_file")"
    fi
    
    # SECURITY: Validate file path is in whitelisted directory (no traversal)
    if [[ "$backup_file" != "$BACKUPS_DIR"/* ]]; then
        echo -e "${RED}✗ SECURITY: Backup file must be in $BACKUPS_DIR${NC}"
        echo "  Provided: $backup_file"
        echo "  Required: $BACKUPS_DIR/"
        return 1
    fi
    
    # SECURITY: Verify file exists and is a regular file (not symlink, device, etc.)
    if [ ! -f "$backup_file" ] || [ ! -r "$backup_file" ]; then
        echo -e "${RED}✗ Backup file not found or not readable: $backup_file${NC}"
        return 1
    fi
    
    # Detect if file is a symbolic link (additional security)
    if [ -L "$backup_file" ]; then
        echo -e "${RED}✗ SECURITY: Symbolic links are not allowed${NC}"
        return 1
    fi
    
    # SECURITY: Check file size constraints (min 1KB, max 10GB)
    local size
    # Use stat (works on both macOS and Linux)
    size=$(stat -f%z "$backup_file" 2>/dev/null || stat -c%s "$backup_file" 2>/dev/null)
    
    if [ -z "$size" ]; then
        echo -e "${RED}✗ Could not determine file size${NC}"
        return 1
    fi
    
    local min_size=1024          # 1KB minimum
    local max_size=10737418240   # 10GB maximum
    
    if [ "$size" -lt "$min_size" ]; then
        echo -e "${RED}✗ Backup file too small (${size} bytes, minimum ${min_size} bytes)${NC}"
        echo "  File may be corrupted or empty"
        return 1
    fi
    
    if [ "$size" -gt "$max_size" ]; then
        echo -e "${RED}✗ Backup file too large (${size} bytes, maximum ${max_size} bytes)${NC}"
        echo "  File may be corrupted or malicious"
        return 1
    fi
    
    # Show details and get confirmation
    echo -e "\n${CYAN}═══ Database Restore ═══${NC}\n"
    echo -e "${YELLOW}⚠ WARNING: This will REPLACE all current databases!${NC}"
    echo ""
    echo "Backup file: $(basename $backup_file)"
    echo "Location: $backup_file"
    echo "Size: $(du -h "$backup_file" | cut -f1) ($(numfmt --to=iec-i --suffix=B $size 2>/dev/null || echo "${size} bytes"))"
    echo "Modified: $(stat -f%Sm "$backup_file" 2>/dev/null || stat -c%y "$backup_file" 2>/dev/null)"
    echo ""
    echo "Services that will be stopped:"
    echo "  - homelab-dashboard"
    echo "  - homelab-celery-worker"
    echo "  - discord-bot"
    echo "  - stream-bot"
    echo ""
    read -p "Type 'yes' to continue: " confirm
    
    if [ "$confirm" != "yes" ]; then
        echo "Restore cancelled"
        return 0
    fi
    
    if ! is_running "homelab-postgres"; then
        echo -e "\n${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    # Stop all services that use the database
    echo -e "\n${CYAN}Stopping dependent services...${NC}"
    compose stop homelab-dashboard homelab-celery-worker discord-bot stream-bot
    sleep 3
    
    # Extract PostgreSQL password from .env (secure method)
    local POSTGRES_PASSWORD=$(grep "^POSTGRES_PASSWORD=" "$ENV_FILE" | cut -d'=' -f2-)
    
    if [ -z "$POSTGRES_PASSWORD" ]; then
        echo -e "${RED}✗ POSTGRES_PASSWORD not found in .env${NC}"
        echo "Restarting services..."
        compose start homelab-dashboard homelab-celery-worker discord-bot stream-bot
        return 1
    fi
    
    # Restore with PGPASSWORD (no credentials in process list)
    echo -e "${CYAN}Restoring databases from backup...${NC}"
    if PGPASSWORD="$POSTGRES_PASSWORD" docker exec -i homelab-postgres \
        psql -U postgres < "$backup_file"; then
        
        # Clear password from environment
        unset POSTGRES_PASSWORD
        
        echo -e "\n${GREEN}✅ Restore completed successfully${NC}"
        echo ""
        echo -e "${CYAN}Restarting services...${NC}"
        compose start homelab-dashboard homelab-celery-worker discord-bot stream-bot
        sleep 5
        
        echo ""
        echo -e "${GREEN}✅ All services restarted${NC}"
        echo "Run './homelab status' to verify services"
        return 0
    else
        # Clear password from environment
        unset POSTGRES_PASSWORD
        
        echo -e "\n${RED}✗ Restore failed${NC}"
        echo -e "${YELLOW}⚠ Services have been stopped for safety${NC}"
        echo ""
        echo "Manual recovery steps:"
        echo "  1. Check logs: docker logs homelab-postgres"
        echo "  2. Verify backup file integrity"
        echo "  3. Restore from another backup"
        echo "  4. Or restart services: ./homelab start"
        return 1
    fi
}

# ============================================
# UPDATE COMMAND - Git Pull and Redeploy
# ============================================
update() {
    echo -e "\n${CYAN}═══ Update Deployment ═══${NC}\n"
    
    cd "$PROJECT_ROOT"
    
    # Check if git repo
    if [ ! -d ".git" ]; then
        echo -e "${RED}✗ Not a git repository${NC}"
        return 1
    fi
    
    # Create backup before update
    echo "Creating pre-update backup..."
    backup
    
    # Fetch updates
    echo ""
    echo "Fetching latest changes..."
    git fetch origin
    
    # Show what would change
    local changes=$(git rev-list HEAD..origin/main --count 2>/dev/null || echo "0")
    
    if [ "$changes" = "0" ]; then
        echo -e "${GREEN}✓ Already up to date${NC}"
        return 0
    fi
    
    echo ""
    echo -e "${YELLOW}$changes commit(s) to pull${NC}"
    git log --oneline HEAD..origin/main | head -5
    echo ""
    read -p "Continue with update? (y/N): " confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Update cancelled"
        return 0
    fi
    
    # Pull changes
    echo ""
    echo "Pulling changes..."
    git pull origin main
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}✗ Git pull failed${NC}"
        echo "Resolve conflicts manually, then run './homelab fix'"
        return 1
    fi
    
    # Rebuild and restart
    echo ""
    echo "Rebuilding and redeploying..."
    compose build
    compose up -d --force-recreate
    
    echo ""
    echo -e "${GREEN}✅ Update completed${NC}"
    echo "Run './homelab health' to verify deployment"
}

# ============================================
# REBUILD COMMAND - Rebuild Specific Service
# ============================================
rebuild() {
    local service="$1"
    
    if [ -z "$service" ]; then
        echo -e "${RED}✗ Usage: ./homelab rebuild <service>${NC}"
        echo ""
        echo "Available services:"
        for svc in "${ALL_SERVICES[@]}"; do
            echo "  - $svc"
        done
        return 1
    fi
    
    echo -e "\n${CYAN}═══ Rebuilding $service ═══${NC}\n"
    
    # Verify service exists in compose
    local compose_service="${service#homelab-}"
    if ! compose config --services 2>/dev/null | grep -q "^${compose_service}$"; then
        echo -e "${RED}✗ Service not found in docker-compose.yml${NC}"
        return 1
    fi
    
    # Rebuild
    echo "Building $compose_service..."
    compose build --no-cache "$compose_service"
    
    if [ $? -eq 0 ]; then
        echo ""
        echo "Recreating container..."
        compose up -d --force-recreate "$compose_service"
        
        echo ""
        echo -e "${GREEN}✅ Rebuild completed${NC}"
        echo "Check logs: ./homelab logs $service"
    else
        echo -e "\n${RED}✗ Rebuild failed${NC}"
        return 1
    fi
}

# ============================================
# CLEAN COMMAND - Cleanup Old Resources
# ============================================
clean() {
    echo -e "\n${CYAN}═══ Cleanup ═══${NC}\n"
    
    local cleaned=0
    
    # 1. Old log files
    echo -e "${CYAN}[1/4] Cleaning old logs${NC}"
    local log_dirs=("$PROJECT_ROOT/logs" "$PROJECT_ROOT/services/dashboard/logs" "$PROJECT_ROOT/services/discord-bot/logs" "$PROJECT_ROOT/services/stream-bot/logs")
    
    for dir in "${log_dirs[@]}"; do
        if [ -d "$dir" ]; then
            # Keep logs from last 7 days, delete older
            local deleted=$(find "$dir" -name "*.log" -type f -mtime +7 -delete -print 2>/dev/null | wc -l)
            if [ "$deleted" -gt 0 ]; then
                echo "  Removed $deleted log file(s) from $(basename $dir)"
                ((cleaned++))
            fi
        fi
    done
    
    if [ $cleaned -eq 0 ]; then
        echo "  No old logs to remove"
    fi
    
    # 2. Old backups
    echo -e "\n${CYAN}[2/4] Cleaning old backups${NC}"
    local backup_dir="$PROJECT_ROOT/backups"
    if [ -d "$backup_dir" ]; then
        cd "$backup_dir"
        # Keep last 10 backups
        local old_backups=$(ls -t homelab-backup-*.sql 2>/dev/null | tail -n +11)
        if [ -n "$old_backups" ]; then
            echo "$old_backups" | xargs rm -f
            local count=$(echo "$old_backups" | wc -l)
            echo "  Removed $count old backup(s)"
        else
            echo "  No old backups to remove"
        fi
    else
        echo "  No backup directory found"
    fi
    
    # 3. Unused Docker images
    echo -e "\n${CYAN}[3/4] Cleaning unused Docker images${NC}"
    docker image prune -f | grep -E "^(Total|Deleted)" || echo "  No unused images"
    
    # 4. Stopped containers
    echo -e "\n${CYAN}[4/4] Cleaning stopped containers${NC}"
    docker container prune -f | grep -E "^(Total|Deleted)" || echo "  No stopped containers"
    
    echo ""
    echo -e "${GREEN}✅ Cleanup completed${NC}"
}

# ============================================
# DB-SHELL COMMAND - PostgreSQL Shell Access
# ============================================
db_shell() {
    local database="${1:-postgres}"
    
    echo -e "${CYAN}═══ PostgreSQL Shell ═══${NC}\n"
    
    if ! is_running "homelab-postgres"; then
        echo -e "${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    echo "Connecting to database: $database"
    echo "Type '\q' or Ctrl+D to exit"
    echo ""
    
    docker exec -it homelab-postgres psql -U postgres -d "$database"
}

# ============================================
# DEPLOYMENT COMMAND - Deployment Management (Phase 6)
# ============================================
deployment_cmd() {
    local subcmd="${1:-help}"
    shift || true
    
    case "$subcmd" in
        history)
            deployment_history
            ;;
        status)
            deployment_status
            ;;
        *)
            echo "Usage: ./homelab deployment <subcommand>"
            echo ""
            echo "Subcommands:"
            echo "  history   - Show deployment history"
            echo "  status    - Show current deployment status"
            ;;
    esac
}

deployment_history() {
    echo -e "${CYAN}═══ Deployment History ═══${NC}\n"
    
    local history_file="$PROJECT_ROOT/.deployments/history.json"
    
    if [ ! -f "$history_file" ]; then
        echo -e "${YELLOW}No deployment history found${NC}"
        return 0
    fi
    
    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}jq not installed - showing raw JSON${NC}"
        cat "$history_file"
        return 0
    fi
    
    # Show last 10 deployments
    echo "Last 10 deployments:"
    echo ""
    
    jq -r '.deployments[-10:] | reverse | .[] | 
        "[\(.timestamp)] \(.action | ascii_upcase) - \(.service) - Status: \(.status)"' \
        "$history_file" 2>/dev/null || cat "$history_file"
    
    echo ""
    echo "Full history: $history_file"
}

deployment_status() {
    echo -e "${CYAN}═══ Deployment Status ═══${NC}\n"
    
    local history_file="$PROJECT_ROOT/.deployments/history.json"
    
    if [ ! -f "$history_file" ]; then
        echo -e "${YELLOW}No deployment information available${NC}"
        return 0
    fi
    
    if ! command -v jq &> /dev/null; then
        echo -e "${YELLOW}jq not installed - install for better display${NC}"
        return 0
    fi
    
    # Show last deployment
    echo "Last deployment:"
    jq -r '.last_deployment | 
        if . != null then
            "  Service: \(.service)\n  Action: \(.action)\n  Status: \(.status)\n  Time: \(.timestamp)\n  Backup: \(.backup // "none")"
        else
            "  No deployments yet"
        end' "$history_file"
    
    echo ""
    
    # Show currently deployed services with their status
    echo "Currently running services:"
    docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Image}}" | grep -E "homelab-|discord-bot|stream-bot" || echo "  None running"
}

# ============================================
# UNIFIED DEPLOYMENT PIPELINE - One Command to Rule Them All
# ============================================
deploy_pipeline() {
    local dry_run=false
    local skip_preflight=false
    local auto_fix=true
    local show_logs=true
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --skip-preflight)
                skip_preflight=true
                shift
                ;;
            --no-autofix)
                auto_fix=false
                shift
                ;;
            --quiet|-q)
                show_logs=false
                shift
                ;;
            --help|-h)
                deploy_pipeline_help
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo ""
    echo -e "${CYAN}╔════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║          UNIFIED DEPLOYMENT PIPELINE                           ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo "  Date: $(date)"
    echo "  Role: $ROLE_NAME"
    echo "  Project: $PROJECT_ROOT"
    echo ""
    
    local pipeline_start=$(date +%s)
    local total_steps=5
    local current_step=0
    local errors=0
    local warnings=0
    local fixes_applied=0
    
    # ─────────────────────────────────────────────────
    # STEP 1: Environment Validation
    # ─────────────────────────────────────────────────
    current_step=$((current_step + 1))
    echo -e "\n${YELLOW}━━━ Step $current_step/$total_steps: Environment Validation ━━━${NC}"
    
    if [ "$ROLE" = "cloud" ] && [ -x "$PROJECT_ROOT/deploy/linode/scripts/validate-env.sh" ]; then
        if "$PROJECT_ROOT/deploy/linode/scripts/validate-env.sh" 2>&1; then
            echo -e "  ${GREEN}✓${NC} Environment variables validated"
        else
            echo -e "  ${RED}✗${NC} Environment validation failed"
            errors=$((errors + 1))
            
            if $auto_fix; then
                echo ""
                echo -e "  ${CYAN}Attempting auto-fix: Checking for missing .env${NC}"
                if [ ! -f "$PROJECT_ROOT/deploy/linode/.env" ] && [ -f "$PROJECT_ROOT/deploy/linode/.env.example" ]; then
                    echo "  Creating .env from template..."
                    cp "$PROJECT_ROOT/deploy/linode/.env.example" "$PROJECT_ROOT/deploy/linode/.env"
                    fixes_applied=$((fixes_applied + 1))
                    echo -e "  ${GREEN}✓${NC} Created .env from template - edit with your secrets!"
                fi
            fi
        fi
    elif [ "$ROLE" = "local" ]; then
        # Check local environment
        if [ -f "$ENV_FILE" ]; then
            echo -e "  ${GREEN}✓${NC} Local .env file exists"
        else
            echo -e "  ${RED}✗${NC} .env file missing"
            errors=$((errors + 1))
            
            if $auto_fix && [ -f "$PROJECT_ROOT/.env.example" ]; then
                cp "$PROJECT_ROOT/.env.example" "$ENV_FILE"
                fixes_applied=$((fixes_applied + 1))
                echo -e "  ${GREEN}✓${NC} Created .env from template"
            fi
        fi
    else
        echo -e "  ${GREEN}✓${NC} Environment check skipped (no validator available)"
    fi
    
    # ─────────────────────────────────────────────────
    # STEP 2: Pre-Flight Checks
    # ─────────────────────────────────────────────────
    current_step=$((current_step + 1))
    echo -e "\n${YELLOW}━━━ Step $current_step/$total_steps: Pre-Flight Checks ━━━${NC}"
    
    if $skip_preflight; then
        echo -e "  ${YELLOW}⊘${NC} Pre-flight checks skipped (--skip-preflight)"
    elif [ "$ROLE" = "cloud" ] && [ -x "$PROJECT_ROOT/deploy/linode/scripts/preflight.sh" ]; then
        if "$PROJECT_ROOT/deploy/linode/scripts/preflight.sh" 2>&1; then
            echo -e "  ${GREEN}✓${NC} Pre-flight checks passed"
        else
            echo -e "  ${YELLOW}⚠${NC} Pre-flight checks had warnings (continuing)"
            warnings=$((warnings + 1))
        fi
    elif [ "$ROLE" = "local" ]; then
        # Local pre-flight checks
        echo "  Checking Docker..."
        if command -v docker &> /dev/null && docker info &> /dev/null; then
            echo -e "  ${GREEN}✓${NC} Docker is running"
        else
            echo -e "  ${RED}✗${NC} Docker is not running"
            errors=$((errors + 1))
            
            if $auto_fix; then
                echo "  Attempting to start Docker..."
                sudo systemctl start docker 2>/dev/null && {
                    fixes_applied=$((fixes_applied + 1))
                    echo -e "  ${GREEN}✓${NC} Docker started"
                } || echo -e "  ${RED}✗${NC} Could not start Docker"
            fi
        fi
        
        # Check NAS mount for local
        echo "  Checking NAS mounts..."
        if mountpoint -q /mnt/nas/all 2>/dev/null; then
            echo -e "  ${GREEN}✓${NC} NAS is mounted at /mnt/nas/all"
            
            # Test write access
            if touch /mnt/nas/all/.write_test_$$ 2>/dev/null; then
                rm -f /mnt/nas/all/.write_test_$$ 2>/dev/null
                echo -e "  ${GREEN}✓${NC} NAS write access confirmed"
            else
                echo -e "  ${YELLOW}⚠${NC} NAS is read-only"
                warnings=$((warnings + 1))
            fi
        else
            echo -e "  ${YELLOW}⚠${NC} NAS not mounted (Plex may have limited content)"
            warnings=$((warnings + 1))
        fi
    else
        echo -e "  ${GREEN}✓${NC} Pre-flight checks skipped (no preflight script)"
    fi
    
    # If there are critical errors and not dry-run, offer to abort
    if [ $errors -gt 0 ] && ! $dry_run; then
        echo ""
        echo -e "${RED}Found $errors critical error(s) during pre-flight.${NC}"
        echo ""
        read -p "Continue anyway? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Deployment aborted."
            return 1
        fi
    fi
    
    # ─────────────────────────────────────────────────
    # STEP 3: Deployment
    # ─────────────────────────────────────────────────
    current_step=$((current_step + 1))
    echo -e "\n${YELLOW}━━━ Step $current_step/$total_steps: Deployment ━━━${NC}"
    
    if $dry_run; then
        echo -e "  ${CYAN}[DRY RUN]${NC} Would deploy all services"
        echo ""
        echo "  Services that would be deployed:"
        for svc in "${ALL_SERVICES[@]}"; do
            echo "    - $svc"
        done
    else
        echo "  Starting deployment..."
        echo ""
        
        if [ "$ROLE" = "cloud" ] && [ -x "$PROJECT_ROOT/deploy/linode/scripts/deploy.sh" ]; then
            # Use Linode deployment script
            if "$PROJECT_ROOT/deploy/linode/scripts/deploy.sh" 2>&1; then
                echo -e "  ${GREEN}✓${NC} Linode deployment complete"
            else
                echo -e "  ${RED}✗${NC} Deployment failed"
                errors=$((errors + 1))
            fi
        elif [ "$ROLE" = "local" ] && [ -x "$PROJECT_ROOT/deploy/local/start-local-services.sh" ]; then
            # Use local deployment script
            if "$PROJECT_ROOT/deploy/local/start-local-services.sh" 2>&1; then
                echo -e "  ${GREEN}✓${NC} Local deployment complete"
            else
                echo -e "  ${RED}✗${NC} Local deployment failed"
                errors=$((errors + 1))
            fi
        else
            # Fallback to compose up
            if compose up -d 2>&1; then
                echo -e "  ${GREEN}✓${NC} Services started"
            else
                echo -e "  ${RED}✗${NC} Compose up failed"
                errors=$((errors + 1))
            fi
        fi
    fi
    
    # ─────────────────────────────────────────────────
    # STEP 4: Health Verification
    # ─────────────────────────────────────────────────
    current_step=$((current_step + 1))
    echo -e "\n${YELLOW}━━━ Step $current_step/$total_steps: Health Verification ━━━${NC}"
    
    if $dry_run; then
        echo -e "  ${CYAN}[DRY RUN]${NC} Would run health checks"
    else
        echo "  Waiting for services to stabilize..."
        sleep 5
        
        local running=$(count_running)
        echo ""
        echo "  Services running: $running / $TOTAL_SERVICES"
        
        if [ $running -eq $TOTAL_SERVICES ]; then
            echo -e "  ${GREEN}✓${NC} All services running!"
        elif [ $running -gt 0 ]; then
            echo -e "  ${YELLOW}⚠${NC} Some services not running"
            warnings=$((warnings + 1))
            
            # Show which services are down
            echo ""
            for svc in "${ALL_SERVICES[@]}"; do
                if ! is_running "$svc"; then
                    echo -e "    ${RED}○${NC} $svc"
                fi
            done
        else
            echo -e "  ${RED}✗${NC} No services running"
            errors=$((errors + 1))
        fi
    fi
    
    # ─────────────────────────────────────────────────
    # STEP 5: Log Summary
    # ─────────────────────────────────────────────────
    current_step=$((current_step + 1))
    echo -e "\n${YELLOW}━━━ Step $current_step/$total_steps: Log Summary ━━━${NC}"
    
    if $dry_run; then
        echo -e "  ${CYAN}[DRY RUN]${NC} Would check logs for errors"
    elif $show_logs; then
        echo "  Checking recent logs for errors..."
        
        # Get recent errors from logs
        local log_errors=$(compose logs --tail=50 2>/dev/null | grep -iE "(error|exception|fail)" | head -5)
        
        if [ -n "$log_errors" ]; then
            echo ""
            echo -e "  ${YELLOW}Recent errors in logs:${NC}"
            echo "$log_errors" | while read line; do
                echo "    $line"
            done | head -10
            warnings=$((warnings + 1))
        else
            echo -e "  ${GREEN}✓${NC} No obvious errors in recent logs"
        fi
    else
        echo -e "  ${CYAN}⊘${NC} Log check skipped (--quiet)"
    fi
    
    # ─────────────────────────────────────────────────
    # SUMMARY
    # ─────────────────────────────────────────────────
    local pipeline_end=$(date +%s)
    local duration=$((pipeline_end - pipeline_start))
    
    echo ""
    echo -e "${CYAN}════════════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}  DEPLOYMENT PIPELINE SUMMARY${NC}"
    echo -e "${CYAN}════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo "  Duration: ${duration}s"
    echo "  Errors: $errors"
    echo "  Warnings: $warnings"
    echo "  Auto-fixes applied: $fixes_applied"
    echo ""
    
    if [ $errors -eq 0 ]; then
        echo -e "${GREEN}  ✅ DEPLOYMENT SUCCESSFUL${NC}"
        echo ""
        echo "  Next steps:"
        echo "    - Check status:  ./homelab status"
        echo "    - View logs:     ./homelab logs"
        echo "    - Run tests:     ./homelab test"
    else
        echo -e "${RED}  ❌ DEPLOYMENT HAD ERRORS${NC}"
        echo ""
        echo "  Troubleshooting:"
        echo "    - Check logs:    ./homelab logs"
        echo "    - Run health:    ./homelab health --full"
        echo "    - Fix issues:    ./homelab fix"
    fi
    
    echo ""
    
    return $errors
}

deploy_pipeline_help() {
    echo "Unified Deployment Pipeline"
    echo ""
    echo "Usage: ./homelab pipeline [OPTIONS]"
    echo ""
    echo "This command runs the complete deployment pipeline:"
    echo "  1. Environment validation"
    echo "  2. Pre-flight checks"
    echo "  3. Deployment"
    echo "  4. Health verification"
    echo "  5. Log analysis"
    echo ""
    echo "Options:"
    echo "  --dry-run         Show what would happen without making changes"
    echo "  --skip-preflight  Skip pre-flight checks"
    echo "  --no-autofix      Disable automatic fixes for common issues"
    echo "  --quiet, -q       Skip log analysis step"
    echo "  --help, -h        Show this help message"
    echo ""
    echo "Examples:"
    echo "  ./homelab pipeline               # Full deployment with auto-fix"
    echo "  ./homelab pipeline --dry-run     # Preview deployment"
    echo "  ./homelab pipeline --no-autofix  # Deploy without auto-fix"
    echo ""
    echo "The pipeline auto-detects whether you're on:"
    echo "  - Local Ubuntu host (uses local deployment scripts)"
    echo "  - Cloud/Linode (uses Linode deployment scripts)"
}

# ============================================
# TEST COMMAND - Integration Tests
# ============================================
test_services() {
    echo -e "\n${CYAN}═══ Integration Tests ═══${NC}\n"
    
    local tests_passed=0
    local tests_failed=0
    
    # Test 1: Database Connectivity
    echo -e "${CYAN}[1/6] Database Connectivity${NC}"
    if docker exec homelab-postgres psql -U postgres -c "SELECT 1" &>/dev/null; then
        echo -e "  ${GREEN}✓ PASS${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL${NC}"
        ((tests_failed++))
    fi
    
    # Test 2: Dashboard API
    echo -e "\n${CYAN}[2/6] Dashboard API${NC}"
    local dash_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ 2>/dev/null || echo "000")
    if [ "$dash_status" = "200" ] || [ "$dash_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $dash_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL (HTTP $dash_status)${NC}"
        ((tests_failed++))
    fi
    
    # Test 3: Discord Bot
    echo -e "\n${CYAN}[3/6] Discord Bot${NC}"
    local discord_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:4000/ 2>/dev/null || echo "000")
    if [ "$discord_status" = "200" ] || [ "$discord_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $discord_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${YELLOW}⚠ SKIP (HTTP $discord_status)${NC} - Service may not have /health endpoint"
        ((tests_passed++))  # Don't fail on this
    fi
    
    # Test 4: Stream Bot
    echo -e "\n${CYAN}[4/6] Stream Bot${NC}"
    local stream_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/ 2>/dev/null || echo "000")
    if [ "$stream_status" = "200" ] || [ "$stream_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $stream_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${YELLOW}⚠ SKIP (HTTP $stream_status)${NC} - Service may not have /health endpoint"
        ((tests_passed++))  # Don't fail on this
    fi
    
    # Test 5: Redis Connection
    echo -e "\n${CYAN}[5/6] Redis Connection${NC}"
    if docker exec homelab-redis redis-cli ping 2>/dev/null | grep -q "PONG"; then
        echo -e "  ${GREEN}✓ PASS${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL${NC}"
        ((tests_failed++))
    fi
    
    # Test 6: MinIO Health
    echo -e "\n${CYAN}[6/6] MinIO Health${NC}"
    local minio_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9000/minio/health/live 2>/dev/null || echo "000")
    if [ "$minio_status" = "200" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $minio_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL (HTTP $minio_status)${NC}"
        ((tests_failed++))
    fi
    
    # Summary
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Results: $tests_passed passed, $tests_failed failed"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    if [ $tests_failed -eq 0 ]; then
        echo -e "${GREEN}✅ All tests passed!${NC}"
        return 0
    else
        echo -e "${RED}⚠ Some tests failed${NC}"
        return 1
    fi
}

# ============================================
# CONFIG MANAGEMENT COMMANDS
# ============================================

config_generate() {
    local env=$1
    local host=$2
    
    if [ -z "$env" ] || [ -z "$host" ]; then
        echo -e "${RED}Usage: ./homelab config generate <env> <host>${NC}"
        echo "Examples:"
        echo "  ./homelab config generate dev localhost"
        echo "  ./homelab config generate prod evindrake.net"
        exit 1
    fi
    
    echo -e "${CYAN}═══ Generating Configuration ═══${NC}\n"
    python3 "$PROJECT_ROOT/config/scripts/generate-config.py" --env "$env" --host "$host"
}

config_validate() {
    local env=$1
    local host=$2
    
    if [ -z "$env" ] || [ -z "$host" ]; then
        echo -e "${RED}Usage: ./homelab config validate <env> <host>${NC}"
        echo "Examples:"
        echo "  ./homelab config validate dev localhost"
        echo "  ./homelab config validate prod evindrake.net"
        exit 1
    fi
    
    echo -e "${CYAN}═══ Validating Configuration ═══${NC}\n"
    python3 "$PROJECT_ROOT/config/scripts/validate-config.py" --env "$env" --host "$host"
}

config_encrypt() {
    echo -e "${CYAN}═══ Encrypting Secrets ═══${NC}\n"
    "$PROJECT_ROOT/config/scripts/encrypt-secrets.sh"
}

# ============================================
# MODULAR DEPLOYMENT COMMANDS (Phase 2)
# ============================================

# Modular compose command
modular_compose() {
    local compose_files="$1"
    shift
    
    # Export DEPLOYMENT_PATH so docker-compose can use it in env_file directives
    export DEPLOYMENT_PATH
    
    docker compose \
        --project-directory "$PROJECT_ROOT" \
        --env-file "$ENV_FILE" \
        $compose_files \
        "$@"
}

# Validate required .env files for a service
validate_service_env() {
    local service_id=$1
    local missing=()
    
    # Check main .env
    if [ ! -f "${DEPLOYMENT_PATH}/.env" ]; then
        missing+=(".env")
    fi
    
    # Check service-specific .env if it should exist
    local service_env="${DEPLOYMENT_PATH}/.env.${service_id}"
    if [ -f "$service_env" ]; then
        # Service has dedicated config, all good
        :
    fi
    
    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${RED}ERROR: Missing required .env files:${NC}"
        for file in "${missing[@]}"; do
            echo "  - ${DEPLOYMENT_PATH}/$file"
        done
        echo ""
        echo "Generate Phase 1 configs first:"
        echo "  python3 config/scripts/generate-config.py prod evindrake_net"
        return 1
    fi
    
    return 0
}

# Get service group from services.yaml
get_service_group() {
    local service=$1
    local catalog="$PROJECT_ROOT/orchestration/services.yaml"
    
    if [ ! -f "$catalog" ]; then
        echo ""
        return
    fi
    
    # Simple grep-based parsing (fallback if yq not available)
    grep -A 50 "^  $service:" "$catalog" 2>/dev/null | grep "group:" | head -1 | awk '{print $2}' || echo ""
}

# Get services in a group
get_group_services() {
    local group=$1
    local catalog="$PROJECT_ROOT/orchestration/services.yaml"
    
    if [ ! -f "$catalog" ]; then
        echo ""
        return
    fi
    
    # Extract services list from group
    grep -A 5 "^  $group:" "$catalog" 2>/dev/null | grep "services:" | sed 's/.*services: \[//' | sed 's/\]//' | tr ',' ' ' || echo ""
}

# Deploy service or group (Phase 2: Dynamic from services.yaml)
deploy_service() {
    local target=$1
    
    if [ -z "$target" ]; then
        echo -e "${RED}Usage: ./homelab deploy <service|group>${NC}"
        echo ""
        echo "Examples:"
        echo "  ./homelab deploy dashboard      # Deploy single service"
        echo "  ./homelab deploy bots           # Deploy service group"
        echo "  ./homelab deploy core           # Deploy core infrastructure"
        echo ""
        echo "Run './homelab services list' to see available services and groups"
        return 1
    fi
    
    local catalog="$PROJECT_ROOT/orchestration/service_catalog.py"
    local orchestration="$PROJECT_ROOT/orchestration"
    
    if [ ! -f "$catalog" ]; then
        echo -e "${RED}ERROR: service_catalog.py not found${NC}"
        return 1
    fi
    
    echo -e "${CYAN}═══ Deploying: $target ═══${NC}\n"
    
    # Check if target is a group
    local group_services=$(python3 "$catalog" group "$target" 2>/dev/null)
    
    if [ -n "$group_services" ]; then
        # It's a group - deploy all services in the group
        echo "Deploying group: $target"
        echo "Services: $group_services"
        echo ""
        
        # Get all services with dependencies
        local services_to_deploy=$(python3 "$catalog" order $group_services 2>/dev/null)
        
        if [ -z "$services_to_deploy" ]; then
            echo -e "${RED}ERROR: Failed to resolve dependencies for group $target${NC}"
            return 1
        fi
        
        echo "Deployment order: $services_to_deploy"
        echo ""
        
        # Build compose file list (unique files only)
        local compose_files_args=""
        local seen_files=()
        
        for svc in $services_to_deploy; do
            # Get compose files for this service
            local svc_files=$(python3 "$catalog" compose "$svc" 2>/dev/null)
            
            for file in $svc_files; do
                # Add to list if not already seen
                if [[ ! " ${seen_files[@]} " =~ " ${file} " ]]; then
                    seen_files+=("$file")
                    compose_files_args="$compose_files_args -f $file"
                fi
            done
        done
        
        # Validate env files
        for svc in $services_to_deploy; do
            validate_service_env "$svc" || return 1
        done
        
        # Deploy
        modular_compose "$compose_files_args" up -d
        
    else
        # Check if it's a single service
        local service_info=$(python3 "$catalog" get "$target" 2>/dev/null)
        
        if [ -z "$service_info" ] || [ "$service_info" = "null" ]; then
            echo -e "${RED}Unknown service or group: $target${NC}"
            echo "Use './homelab services list' to see available options"
            return 1
        fi
        
        echo "Deploying service: $target"
        
        # Get dependencies and deployment order
        local all_services=$(python3 "$catalog" order "$target" 2>/dev/null)
        
        if [ -z "$all_services" ]; then
            echo -e "${RED}ERROR: Failed to resolve dependencies for $target${NC}"
            return 1
        fi
        
        echo "With dependencies: $all_services"
        echo ""
        
        # Build compose file list
        local compose_files_args=""
        local seen_files=()
        
        for svc in $all_services; do
            local svc_files=$(python3 "$catalog" compose "$svc" 2>/dev/null)
            
            for file in $svc_files; do
                if [[ ! " ${seen_files[@]} " =~ " ${file} " ]]; then
                    seen_files+=("$file")
                    compose_files_args="$compose_files_args -f $file"
                fi
            done
        done
        
        # Validate env files
        for svc in $all_services; do
            validate_service_env "$svc" || return 1
        done
        
        # Deploy
        modular_compose "$compose_files_args" up -d
    fi
    
    echo ""
    echo -e "${GREEN}✓ Deployment complete${NC}"
    echo "Check status: ./homelab status"
}

# Undeploy service or group (Phase 2: Dynamic from services.yaml)
undeploy_service() {
    local target=$1
    
    if [ -z "$target" ]; then
        echo -e "${RED}Usage: ./homelab undeploy <service|group>${NC}"
        return 1
    fi
    
    local catalog="$PROJECT_ROOT/orchestration/service_catalog.py"
    
    if [ ! -f "$catalog" ]; then
        echo -e "${RED}ERROR: service_catalog.py not found${NC}"
        return 1
    fi
    
    echo -e "${CYAN}═══ Undeploying: $target ═══${NC}\n"
    
    # Check if target is a group
    local group_services=$(python3 "$catalog" group "$target" 2>/dev/null)
    
    if [ -n "$group_services" ]; then
        # It's a group
        echo "Undeploying group: $target"
        echo "Services: $group_services"
        echo ""
        
        # Warn if undeploying core infrastructure
        if [ "$target" = "core" ]; then
            echo -e "${YELLOW}Warning: This will stop core infrastructure${NC}"
            echo "Other services may fail without core services."
            read -p "Continue? (y/N) " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Cancelled."
                return 0
            fi
        fi
        
        # Build compose file list for the group
        local compose_files_args=""
        local seen_files=()
        
        for svc in $group_services; do
            local svc_files=$(python3 "$catalog" compose "$svc" 2>/dev/null)
            
            for file in $svc_files; do
                if [[ ! " ${seen_files[@]} " =~ " ${file} " ]]; then
                    seen_files+=("$file")
                    compose_files_args="$compose_files_args -f $file"
                fi
            done
        done
        
        # Stop the services
        modular_compose "$compose_files_args" down
        
    else
        # Check if it's a single service
        local service_info=$(python3 "$catalog" get "$target" 2>/dev/null)
        
        if [ -z "$service_info" ] || [ "$service_info" = "null" ]; then
            # Try to stop by container name as fallback
            echo "Service not in catalog, trying container name..."
            docker stop "$target" 2>/dev/null && docker rm "$target" 2>/dev/null || {
                echo -e "${RED}Unknown service: $target${NC}"
                echo "Use './homelab services list' to see available options"
                return 1
            }
        else
            echo "Undeploying service: $target"
            
            # Get compose files for this service only (not dependencies)
            local compose_files_args=""
            local seen_files=()
            local svc_files=$(python3 "$catalog" compose "$target" 2>/dev/null)
            
            for file in $svc_files; do
                if [[ ! " ${seen_files[@]} " =~ " ${file} " ]]; then
                    seen_files+=("$file")
                    compose_files_args="$compose_files_args -f $file"
                fi
            done
            
            # Get container name from service
            local container_name=$(echo "$service_info" | python3 -c "import sys, json; data = json.load(sys.stdin); print(data.get('container_name', ''))" 2>/dev/null)
            
            if [ -n "$container_name" ]; then
                # Stop specific container
                docker stop "$container_name" 2>/dev/null && docker rm "$container_name" 2>/dev/null
            else
                # Fallback to compose down
                modular_compose "$compose_files_args" down
            fi
        fi
    fi
    
    echo -e "${GREEN}✓ Undeploy complete${NC}"
}

# Services management
services_cmd() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list|ls)
            echo -e "${CYAN}═══ Available Services & Groups ═══${NC}\n"
            echo -e "${GREEN}Service Groups:${NC}"
            echo "  core          - Core infrastructure (postgres, redis, minio, caddy)"
            echo "  bots          - Discord & Stream bots"
            echo "  web           - Web applications (n8n, homeassistant, static sites)"
            echo "  automation    - Background workers (celery)"
            echo "  development   - Dev tools (vnc-desktop, code-server)"
            echo ""
            echo -e "${GREEN}Individual Services:${NC}"
            echo "  dashboard     - Homelab management dashboard"
            echo "  discord-bot   - Discord ticket management bot"
            echo "  stream-bot    - Twitch/YouTube streaming bot"
            echo "  celery-worker - Background task processor"
            echo "  n8n           - Workflow automation"
            echo "  homeassistant - Smart home hub"
            echo "  vnc-desktop   - Remote desktop"
            echo "  code-server   - VS Code in browser"
            echo ""
            echo "Usage:"
            echo "  ./homelab deploy <service|group>"
            echo "  ./homelab undeploy <service|group>"
            ;;
        deps|dependencies)
            local target=$2
            if [ -z "$target" ]; then
                echo -e "${RED}Usage: ./homelab services deps <service>${NC}"
                return 1
            fi
            
            echo -e "${CYAN}═══ Dependencies for: $target ═══${NC}\n"
            case "$target" in
                dashboard)
                    echo "Required: postgres, redis, minio"
                    echo "Optional: homeassistant"
                    ;;
                discord-bot)
                    echo "Required: postgres"
                    ;;
                stream-bot)
                    echo "Required: postgres"
                    ;;
                celery-worker)
                    echo "Required: postgres, redis"
                    ;;
                *)
                    echo "No dependencies or unknown service"
                    ;;
            esac
            ;;
        catalog)
            if [ -f "$PROJECT_ROOT/orchestration/services.yaml" ]; then
                cat "$PROJECT_ROOT/orchestration/services.yaml"
            else
                echo -e "${RED}Service catalog not found${NC}"
            fi
            ;;
        discover)
            echo -e "\n${CYAN}═══ Discovered Services (Consul) ═══${NC}\n"
            
            if docker ps --format "{{.Names}}" | grep -q "^consul-server$"; then
                if command -v jq &> /dev/null; then
                    curl -s http://localhost:8500/v1/catalog/services 2>/dev/null | jq -r 'to_entries[] | "\(.key) (tags: \(.value | join(", ")))"' || echo "No services registered"
                else
                    curl -s http://localhost:8500/v1/catalog/services 2>/dev/null || echo "No services registered"
                fi
            else
                echo -e "${YELLOW}⚠ Consul not running${NC}"
                echo "Start Consul: docker compose -f orchestration/compose.consul.yml up -d"
            fi
            ;;
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: ./homelab services [list|deps|catalog|discover]"
            return 1
            ;;
    esac
}

# ============================================
# ROUTES COMMAND - Show Traefik Routes
# ============================================
routes_cmd() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list)
            echo -e "\n${CYAN}═══ Traefik Routes ═══${NC}\n"
            
            if docker ps --format "{{.Names}}" | grep -q "^traefik$"; then
                echo "Fetching routes from Traefik API..."
                echo ""
                
                if command -v jq &> /dev/null; then
                    echo -e "${CYAN}HTTP Routers:${NC}"
                    curl -s http://localhost:8080/api/http/routers 2>/dev/null | jq -r '.[] | "  \(.name): \(.rule) -> \(.service)"' || echo "  No HTTP routers"
                    
                    echo ""
                    echo -e "${CYAN}Services:${NC}"
                    curl -s http://localhost:8080/api/http/services 2>/dev/null | jq -r '.[] | "  \(.name): \(.loadBalancer.servers[0].url // "no backend")"' || echo "  No services"
                else
                    echo "Install jq for formatted output: sudo apt install jq"
                    curl -s http://localhost:8080/api/http/routers 2>/dev/null || echo "No routes"
                fi
            else
                echo -e "${YELLOW}⚠ Traefik not running${NC}"
                echo "Start Traefik: docker compose -f orchestration/compose.traefik.yml up -d"
            fi
            ;;
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: ./homelab routes [list]"
            return 1
            ;;
    esac
}

# ============================================
# DATABASE COMMAND - Phase 4 Database Management
# ============================================
db_cmd() {
    local subcmd="${1:-status}"
    
    case "$subcmd" in
        status)
            echo -e "\n${CYAN}═══ Database Platform Status ═══${NC}\n"
            
            # PostgreSQL Status
            echo -e "${CYAN}[1/4] PostgreSQL Database${NC}"
            if is_running "homelab-postgres"; then
                if docker exec homelab-postgres pg_isready -U postgres &>/dev/null; then
                    echo -e "  ${GREEN}✓${NC} PostgreSQL responding"
                    
                    # List databases
                    echo -e "\n  ${CYAN}Databases:${NC}"
                    docker exec homelab-postgres psql -U postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -v "^$" | grep -v "template" | while read db; do
                        echo "    - $db"
                    done
                else
                    echo -e "  ${RED}✗${NC} PostgreSQL not responding"
                fi
            else
                echo -e "  ${RED}✗${NC} PostgreSQL container not running"
            fi
            
            # pgBouncer Status
            echo -e "\n${CYAN}[2/4] pgBouncer Connection Pooler${NC}"
            if is_running "homelab-pgbouncer"; then
                echo -e "  ${GREEN}✓${NC} pgBouncer running on port 6432"
                echo -e "  ${CYAN}Pool Stats:${NC}"
                docker exec homelab-pgbouncer psql -h localhost -p 6432 -U postgres -d pgbouncer -c "SHOW POOLS;" 2>/dev/null || echo "    Unable to fetch stats"
            else
                echo -e "  ${YELLOW}⚠${NC} pgBouncer not running (optional)"
            fi
            
            # pgBackRest Status
            echo -e "\n${CYAN}[3/4] pgBackRest Backup Service${NC}"
            if is_running "homelab-pgbackrest"; then
                echo -e "  ${GREEN}✓${NC} pgBackRest running"
                echo -e "  ${CYAN}Backup Info:${NC}"
                docker exec homelab-pgbackrest pgbackrest --stanza=homelab info 2>/dev/null || echo "    No backups yet"
            else
                echo -e "  ${YELLOW}⚠${NC} pgBackRest not running (optional)"
            fi
            
            # Backup Scheduler Status
            echo -e "\n${CYAN}[4/4] Backup Scheduler${NC}"
            if is_running "homelab-backup-scheduler"; then
                echo -e "  ${GREEN}✓${NC} Backup scheduler running"
                echo -e "  ${CYAN}Schedule:${NC}"
                echo "    Full backup: Daily at 2 AM"
                echo "    Incremental: Every hour"
            else
                echo -e "  ${YELLOW}⚠${NC} Backup scheduler not running (optional)"
            fi
            ;;
            
        backup)
            echo -e "\n${CYAN}═══ Manual Database Backup ═══${NC}\n"
            
            if ! is_running "homelab-pgbackrest"; then
                echo -e "${RED}✗ pgBackRest not running${NC}"
                echo "Start with: ./homelab deploy database"
                return 1
            fi
            
            local backup_type="${2:-full}"
            echo "Starting $backup_type backup..."
            docker exec homelab-pgbackrest pgbackrest --stanza=homelab --type=$backup_type backup
            
            if [ $? -eq 0 ]; then
                echo -e "\n${GREEN}✓ Backup completed successfully${NC}"
                echo ""
                ./homelab db list-backups
            else
                echo -e "\n${RED}✗ Backup failed${NC}"
                return 1
            fi
            ;;
            
        restore)
            local backup_id="$2"
            
            if [ -z "$backup_id" ]; then
                echo -e "${RED}Error: Backup ID required${NC}"
                echo "Usage: ./homelab db restore <backup-id>"
                echo ""
                echo "Available backups:"
                ./homelab db list-backups
                return 1
            fi
            
            echo -e "\n${RED}⚠ WARNING: This will restore the database!${NC}"
            echo "This will stop all services and restore from backup."
            read -p "Are you sure? (yes/no): " confirm
            
            if [ "$confirm" != "yes" ]; then
                echo "Restore cancelled"
                return 0
            fi
            
            echo -e "\n${CYAN}Stopping services...${NC}"
            compose down
            
            echo -e "${CYAN}Restoring database from $backup_id...${NC}"
            docker exec homelab-pgbackrest pgbackrest --stanza=homelab --set=$backup_id restore
            
            if [ $? -eq 0 ]; then
                echo -e "\n${GREEN}✓ Restore completed${NC}"
                echo "Restarting services..."
                ./homelab fix
            else
                echo -e "\n${RED}✗ Restore failed${NC}"
                return 1
            fi
            ;;
            
        list-backups)
            echo -e "\n${CYAN}═══ Available Backups ═══${NC}\n"
            
            if ! is_running "homelab-pgbackrest"; then
                echo -e "${YELLOW}⚠ pgBackRest not running${NC}"
                echo "No backups available"
                return 0
            fi
            
            docker exec homelab-pgbackrest pgbackrest --stanza=homelab info
            ;;
            
        migrate)
            local service="$2"
            
            if [ -z "$service" ]; then
                echo -e "${RED}Error: Service name required${NC}"
                echo "Usage: ./homelab db migrate <service>"
                echo ""
                echo "Available services:"
                echo "  - dashboard (Alembic migrations)"
                echo "  - discord-bot (Drizzle migrations)"
                echo "  - stream-bot (Drizzle migrations)"
                return 1
            fi
            
            echo -e "\n${CYAN}═══ Running Migrations for $service ═══${NC}\n"
            
            case "$service" in
                dashboard)
                    if is_running "homelab-dashboard"; then
                        docker exec homelab-dashboard alembic upgrade head
                    else
                        echo -e "${RED}✗ Dashboard not running${NC}"
                        return 1
                    fi
                    ;;
                discord-bot)
                    if is_running "discord-bot"; then
                        docker exec discord-bot npm run db:push
                    else
                        echo -e "${RED}✗ Discord bot not running${NC}"
                        return 1
                    fi
                    ;;
                stream-bot)
                    if is_running "stream-bot"; then
                        docker exec stream-bot npm run db:push
                    else
                        echo -e "${RED}✗ Stream bot not running${NC}"
                        return 1
                    fi
                    ;;
                *)
                    echo -e "${RED}Unknown service: $service${NC}"
                    return 1
                    ;;
            esac
            
            if [ $? -eq 0 ]; then
                echo -e "\n${GREEN}✓ Migrations completed${NC}"
            else
                echo -e "\n${RED}✗ Migrations failed${NC}"
                return 1
            fi
            ;;
            
        help|*)
            cat << 'EOF'
╔════════════════════════════════════════════════════════╗
║          DATABASE MANAGEMENT (Phase 4)                 ║
╚════════════════════════════════════════════════════════╝

COMMANDS:
  ./homelab db status                - Show database platform status
  ./homelab db backup [type]         - Trigger manual backup (full|incr|diff)
  ./homelab db restore <backup-id>   - Restore from backup
  ./homelab db list-backups          - List available backups
  ./homelab db migrate <service>     - Run migrations for service

EXAMPLES:
  ./homelab db status                      # Show database health
  ./homelab db backup full                 # Full backup now
  ./homelab db backup incr                 # Incremental backup
  ./homelab db list-backups                # List backups
  ./homelab db restore 20251123-120000F    # Restore from backup
  ./homelab db migrate dashboard           # Run dashboard migrations
  ./homelab db migrate discord-bot         # Run Discord bot migrations

FEATURES:
  - pgBouncer: Connection pooling on port 6432
  - pgBackRest: Automated backups to MinIO
  - WAL Archiving: Point-in-time recovery
  - Automated Schedules: Daily full + hourly incremental

See orchestration/PHASE4_DATABASE_UPGRADE.md for details.
EOF
            ;;
    esac
}

# ============================================
# NETWORK COMMAND - Tailscale Network Info
# ============================================
network_cmd() {
    local subcmd="${1:-status}"
    
    case "$subcmd" in
        status)
            echo -e "\n${CYAN}═══ Network Status ═══${NC}\n"
            
            if command -v tailscale &> /dev/null; then
                echo -e "${CYAN}Tailscale Status:${NC}"
                tailscale status 2>/dev/null || echo "Not connected"
            elif docker ps --format "{{.Names}}" | grep -q "^tailscale$"; then
                echo -e "${CYAN}Tailscale Status (Container):${NC}"
                docker exec tailscale tailscale status 2>/dev/null || echo "Not connected"
            else
                echo -e "${YELLOW}⚠ Tailscale not installed${NC}"
                echo "Install: curl -fsSL https://tailscale.com/install.sh | sh"
                echo "Or see: orchestration/TAILSCALE_SETUP.md"
            fi
            ;;
        peers)
            echo -e "\n${CYAN}═══ Tailscale Network Peers ═══${NC}\n"
            
            if command -v tailscale &> /dev/null; then
                tailscale status 2>/dev/null | grep -v "^#" || echo "No peers"
            elif docker ps --format "{{.Names}}" | grep -q "^tailscale$"; then
                docker exec tailscale tailscale status 2>/dev/null | grep -v "^#" || echo "No peers"
            else
                echo -e "${YELLOW}⚠ Tailscale not installed${NC}"
            fi
            ;;
        routes)
            echo -e "\n${CYAN}═══ Tailscale Routes ═══${NC}\n"
            
            if command -v tailscale &> /dev/null; then
                echo -e "${CYAN}Advertised Routes:${NC}"
                tailscale status --json 2>/dev/null | grep -o '"AdvertiseRoutes":\[.*\]' || echo "No routes advertised"
            elif docker ps --format "{{.Names}}" | grep -q "^tailscale$"; then
                docker exec tailscale tailscale status --json 2>/dev/null | grep -o '"AdvertiseRoutes":\[.*\]' || echo "No routes advertised"
            else
                echo -e "${YELLOW}⚠ Tailscale not installed${NC}"
            fi
            ;;
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: ./homelab network [status|peers|routes]"
            return 1
            ;;
    esac
}

# ============================================
# METRICS COMMAND - Open Grafana Dashboards
# ============================================
metrics() {
    echo -e "\n${CYAN}═══ Grafana Dashboards ═══${NC}\n"
    
    if ! is_running "homelab-grafana"; then
        echo -e "${RED}✗ Grafana is not running${NC}"
        echo "Start with: ./homelab deploy observability"
        return 1
    fi
    
    echo -e "${GREEN}✓${NC} Grafana is running"
    echo ""
    echo "Dashboard URLs:"
    echo "  Main: http://localhost:3000"
    echo "  Homelab Overview: http://localhost:3000/d/homelab-overview"
    echo "  Database: http://localhost:3000/d/homelab-database"
    echo ""
    echo "Login: admin / (see GRAFANA_ADMIN_PASSWORD in .env)"
    echo ""
    
    # Check if Prometheus is collecting metrics
    if is_running "homelab-prometheus"; then
        echo -e "${GREEN}✓${NC} Prometheus is collecting metrics"
        echo "  Prometheus UI: http://localhost:9090"
        echo "  Metrics endpoint: http://localhost:9090/metrics"
        echo ""
        
        # Show active targets
        echo "Active scrape targets:"
        curl -s http://localhost:9090/api/v1/targets 2>/dev/null | \
            grep -o '"job":"[^"]*"' | cut -d'"' -f4 | sort -u | \
            while read -r job; do
                echo "  - $job"
            done
    else
        echo -e "${YELLOW}⚠${NC} Prometheus is not running"
        echo "Start with: ./homelab deploy observability"
    fi
    
    echo ""
    echo "Opening Grafana in browser..."
    if command -v xdg-open &> /dev/null; then
        xdg-open "http://localhost:3000" &>/dev/null &
    elif command -v open &> /dev/null; then
        open "http://localhost:3000" &>/dev/null &
    else
        echo "Visit: http://localhost:3000"
    fi
}

# ============================================
# ALERTS COMMAND - Show Prometheus Alerts
# ============================================
alerts() {
    echo -e "\n${CYAN}═══ Active Prometheus Alerts ═══${NC}\n"
    
    if ! is_running "homelab-prometheus"; then
        echo -e "${RED}✗ Prometheus is not running${NC}"
        echo "Start with: ./homelab deploy observability"
        return 1
    fi
    
    # Fetch active alerts from Prometheus API
    local alerts_json=$(curl -s http://localhost:9090/api/v1/alerts 2>/dev/null)
    
    if [ -z "$alerts_json" ]; then
        echo -e "${RED}✗ Could not fetch alerts from Prometheus${NC}"
        return 1
    fi
    
    # Parse and display alerts
    local firing_count=$(echo "$alerts_json" | grep -o '"state":"firing"' | wc -l)
    local pending_count=$(echo "$alerts_json" | grep -o '"state":"pending"' | wc -l)
    
    if [ "$firing_count" -eq 0 ] && [ "$pending_count" -eq 0 ]; then
        echo -e "${GREEN}✅ No active alerts${NC}"
        echo ""
        echo "All systems nominal!"
    else
        if [ "$firing_count" -gt 0 ]; then
            echo -e "${RED}🔥 FIRING ALERTS: $firing_count${NC}"
            echo ""
        fi
        
        if [ "$pending_count" -gt 0 ]; then
            echo -e "${YELLOW}⏳ PENDING ALERTS: $pending_count${NC}"
            echo ""
        fi
        
        # Show detailed alert info
        echo "Alert Details:"
        curl -s http://localhost:9090/api/v1/alerts 2>/dev/null | \
            grep -o '"alertname":"[^"]*"' | cut -d'"' -f4 | sort -u | \
            while read -r alert; do
                echo "  - $alert"
            done
    fi
    
    echo ""
    echo "View all alerts: http://localhost:9090/alerts"
    echo "Alertmanager: http://localhost:9093 (if enabled)"
}

config_help() {
    cat << 'EOF'
╔════════════════════════════════════════════════════════╗
║         CONFIGURATION MANAGEMENT (SOPS + Age)          ║
╚════════════════════════════════════════════════════════╝

COMMANDS:
  ./homelab config generate <env> <host>  - Generate configs
  ./homelab config validate <env> <host>  - Validate configs
  ./homelab config encrypt                - Encrypt secrets

EXAMPLES:
  # Development
  ./homelab config generate dev localhost
  ./homelab config validate dev localhost

  # Production
  ./homelab config generate prod evindrake.net
  ./homelab config validate prod evindrake.net
  ./homelab config generate prod rig-city.com

  # Encrypt secrets after editing
  sops config/secrets/base.enc.yaml  # Edit secrets
  ./homelab config encrypt           # Re-encrypt

WORKFLOW:
  1. Edit secrets: sops config/secrets/base.enc.yaml
  2. Generate config: ./homelab config generate prod evindrake.net
  3. Validate: ./homelab config validate prod evindrake.net
  4. Deploy: Copy deployment/prod/evindrake_net/.env to server

See config/README.md for complete documentation.
EOF
}

# ============================================

# ============================================
# GATEWAY COMMAND - API Gateway Management (Phase 7)
# ============================================
gateway_cmd() {
    local subcmd="${1:-status}"
    
    case "$subcmd" in
        status)
            echo -e "\n${CYAN}═══ API Gateway Status ═══${NC}\n"
            
            # Check Traefik
            if is_running "traefik"; then
                echo -e "${GREEN}✓${NC} Traefik API Gateway is running"
                echo ""
                
                # Get router count
                local routers=$(docker exec traefik wget -qO- http://localhost:8080/api/http/routers 2>/dev/null | grep -o '"name":"[^"]*"' | wc -l)
                local middlewares=$(docker exec traefik wget -qO- http://localhost:8080/api/http/middlewares 2>/dev/null | grep -o '"name":"[^"]*"' | wc -l)
                
                echo "Active Routes: $routers"
                echo "Middlewares: $middlewares"
                echo ""
                
                # Check auth service
                if is_running "homelab-auth-service"; then
                    echo -e "${GREEN}✓${NC} Auth Service is running"
                    
                    # Test auth service health
                    if curl -sf http://localhost:8000/health >/dev/null 2>&1; then
                        echo -e "${GREEN}✓${NC} Auth Service is healthy"
                    else
                        echo -e "${YELLOW}⚠${NC} Auth Service is not responding to health checks"
                    fi
                else
                    echo -e "${RED}✗${NC} Auth Service is not running"
                    echo "Start with: docker compose up -d homelab-auth-service"
                fi
                
                echo ""
                echo "Dashboard URLs:"
                echo "  Traefik Dashboard: https://traefik.evindrake.net"
                echo "  Auth Service: https://auth.evindrake.net"
                echo ""
                echo "Access Logs: docker exec traefik tail -f /data/access.log"
            else
                echo -e "${RED}✗${NC} Traefik is not running"
                echo "Start with: ./homelab deploy core"
                return 1
            fi
            ;;
        
        tokens)
            echo -e "\n${CYAN}═══ Service Authentication Tokens ═══${NC}\n"
            
            if ! is_running "homelab-auth-service"; then
                echo -e "${RED}✗${NC} Auth Service is not running"
                echo "Start with: docker compose up -d homelab-auth-service"
                return 1
            fi
            
            # Try to fetch tokens (requires a service token)
            # For demo purposes, we'll list from env vars
            echo "Registered service tokens (from environment):"
            echo ""
            
            local has_tokens=false
            for var in SERVICE_TOKEN_DASHBOARD SERVICE_TOKEN_DISCORD_BOT SERVICE_TOKEN_STREAM_BOT SERVICE_TOKEN_CELERY_WORKER; do
                if grep -q "^$var=" "$ENV_FILE" 2>/dev/null; then
                    local service_name=$(echo "$var" | sed 's/SERVICE_TOKEN_//' | tr '[:upper:]' '[:lower:]' | tr '_' '-')
                    echo -e "  ${GREEN}✓${NC} $service_name"
                    has_tokens=true
                fi
            done
            
            if [ "$has_tokens" = false ]; then
                echo -e "  ${YELLOW}⚠${NC} No service tokens configured"
                echo ""
                echo "Generate tokens with: ./homelab gateway generate-token <service-name>"
            fi
            
            echo ""
            echo "To list all tokens via API (requires admin service token):"
            echo "  curl http://localhost:8000/api/v1/auth/tokens \\"
            echo "    -H 'Authorization: Bearer <admin-token>'"
            ;;
        
        generate-token)
            shift
            local service_name="${1:-}"
            
            if [ -z "$service_name" ]; then
                echo -e "${RED}Error: Service name required${NC}"
                echo "Usage: ./homelab gateway generate-token <service-name>"
                echo ""
                echo "Examples:"
                echo "  ./homelab gateway generate-token discord-bot"
                echo "  ./homelab gateway generate-token dashboard"
                return 1
            fi
            
            echo -e "\n${CYAN}═══ Generating Service Token ═══${NC}\n"
            
            if ! is_running "homelab-auth-service"; then
                echo -e "${RED}✗${NC} Auth Service is not running"
                echo "Start with: docker compose up -d homelab-auth-service"
                return 1
            fi
            
            # Generate a secure random token
            local token=$(openssl rand -base64 32 | tr -d '=' | tr '+/' '-_')
            local env_var="SERVICE_TOKEN_$(echo "$service_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')"
            
            echo -e "${GREEN}✓${NC} Service Token Generated"
            echo ""
            echo "Service: $service_name"
            echo "Token: $token"
            echo ""
            echo "Add to your .env file:"
            echo ""
            echo "  $env_var=$token"
            echo ""
            echo "Then restart services:"
            echo "  ./homelab restart"
            ;;
        
        logs)
            shift
            local follow_mode=false
            
            if [ "${1:-}" = "--follow" ] || [ "${1:-}" = "-f" ]; then
                follow_mode=true
            fi
            
            echo -e "\n${CYAN}═══ API Gateway Access Logs ═══${NC}\n"
            
            if ! is_running "traefik"; then
                echo -e "${RED}✗${NC} Traefik is not running"
                return 1
            fi
            
            if [ "$follow_mode" = true ]; then
                echo "Following access logs (Ctrl+C to exit)..."
                echo ""
                docker exec traefik tail -f /data/access.log 2>/dev/null | \
                    while IFS= read -r line; do
                        # Parse JSON log and format nicely
                        if command -v jq &> /dev/null; then
                            echo "$line" | jq -r '"\(.time) \(.RouterName) \(.RequestMethod) \(.RequestPath) \(.OriginStatus) \(.Duration)"' 2>/dev/null || echo "$line"
                        else
                            echo "$line"
                        fi
                    done
            else
                echo "Last 50 access log entries:"
                echo ""
                docker exec traefik tail -50 /data/access.log 2>/dev/null | \
                    while IFS= read -r line; do
                        if command -v jq &> /dev/null; then
                            echo "$line" | jq -r '"\(.time) \(.RouterName) \(.RequestMethod) \(.RequestPath) \(.OriginStatus) \(.Duration)"' 2>/dev/null || echo "$line"
                        else
                            echo "$line"
                        fi
                    done
                
                echo ""
                echo "For live logs, use: ./homelab gateway logs --follow"
            fi
            ;;
        
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: ./homelab gateway [status|tokens|generate-token|logs]"
            echo ""
            echo "Commands:"
            echo "  status               - Show gateway health and routes"
            echo "  tokens               - List registered service tokens"
            echo "  generate-token <svc> - Generate new service token"
            echo "  logs [--follow]      - View gateway access logs"
            return 1
            ;;
    esac
}

# ============================================
# DNS COMMAND - Phase 8 DNS Automation
# ============================================
dns_cmd() {
    local subcmd="${1:-status}"
    
    case "$subcmd" in
        status)
            echo -e "\n${CYAN}═══ DNS Manager Status ═══${NC}\n"
            
            if ! is_running "dns-manager"; then
                echo -e "${RED}✗${NC} DNS Manager is not running"
                echo "Start with: docker compose -f orchestration/compose.dns.yml up -d"
                return 1
            fi
            
            echo -e "${GREEN}✓${NC} DNS Manager is running"
            
            # Get DNS manager health
            if command -v curl &> /dev/null; then
                echo ""
                echo -e "${CYAN}Health Check:${NC}"
                curl -s http://localhost:8001/health | jq '.' 2>/dev/null || echo "  Health check unavailable"
                
                echo ""
                echo -e "${CYAN}Managed Zones:${NC}"
                curl -s http://localhost:8001/api/dns/zones | jq -r '.zones[]' 2>/dev/null | while read zone; do
                    echo "  - $zone"
                done || echo "  No zones configured"
            fi
            ;;
        
        list)
            shift
            local zone="${1:-}"
            
            if [ -z "$zone" ]; then
                echo -e "${RED}Error: Zone name required${NC}"
                echo "Usage: ./homelab dns list <zone>"
                echo ""
                echo "Available zones:"
                echo "  - evindrake.net"
                echo "  - rig-city.com"
                echo "  - scarletredjoker.com"
                return 1
            fi
            
            echo -e "\n${CYAN}═══ DNS Records for $zone ═══${NC}\n"
            
            if ! is_running "dns-manager"; then
                echo -e "${RED}✗${NC} DNS Manager is not running"
                echo "Start with: docker compose -f orchestration/compose.dns.yml up -d"
                return 1
            fi
            
            if command -v curl &> /dev/null && command -v jq &> /dev/null; then
                curl -s "http://localhost:8001/api/dns/records/$zone" | \
                    jq -r '.records[] | "\(.type)\t\(.name)\t\(.content)\tTTL: \(.ttl)\tProxied: \(.proxied)"' | \
                    column -t -s $'\t'
            else
                echo "Install curl and jq for formatted output: sudo apt install curl jq"
                curl -s "http://localhost:8001/api/dns/records/$zone"
            fi
            ;;
        
        sync)
            echo -e "\n${CYAN}═══ Syncing DNS Records from services.yaml ═══${NC}\n"
            
            if ! is_running "dns-manager"; then
                echo -e "${RED}✗${NC} DNS Manager is not running"
                echo "Start with: docker compose -f orchestration/compose.dns.yml up -d"
                return 1
            fi
            
            if command -v curl &> /dev/null; then
                echo "Triggering DNS sync..."
                local result=$(curl -s -X POST http://localhost:8001/api/dns/sync)
                
                if command -v jq &> /dev/null; then
                    echo ""
                    echo -e "${GREEN}✓${NC} Sync complete!"
                    echo ""
                    echo "Results:"
                    echo "$result" | jq -r '.stats | "  Created/Updated: \(.success)\n  Failed: \(.failed)\n  Skipped: \(.skipped)"'
                else
                    echo "$result"
                fi
            else
                echo "Install curl: sudo apt install curl"
            fi
            ;;
        
        create)
            shift
            local name="${1:-}"
            local target="${2:-}"
            
            if [ -z "$name" ] || [ -z "$target" ]; then
                echo -e "${RED}Error: Name and target required${NC}"
                echo "Usage: ./homelab dns create <name> <target>"
                echo ""
                echo "Examples:"
                echo "  ./homelab dns create test.evindrake.net 192.168.1.100"
                echo "  ./homelab dns create api.rig-city.com evindrake.net"
                return 1
            fi
            
            echo -e "\n${CYAN}═══ Creating DNS Record ═══${NC}\n"
            echo "Name: $name"
            echo "Target: $target"
            echo ""
            echo -e "${YELLOW}⚠${NC} This feature requires manual API access to DNS manager"
            echo ""
            echo "To create manually, add to services.yaml:"
            echo "  dns:"
            echo "    records:"
            echo "      - type: A"
            echo "        name: $name"
            echo "        content: $target"
            echo "        ttl: 300"
            echo "        proxied: true"
            echo ""
            echo "Then run: ./homelab dns sync"
            ;;
        
        delete)
            shift
            local name="${1:-}"
            
            if [ -z "$name" ]; then
                echo -e "${RED}Error: Record name required${NC}"
                echo "Usage: ./homelab dns delete <name>"
                echo ""
                echo "Example:"
                echo "  ./homelab dns delete test.evindrake.net"
                return 1
            fi
            
            echo -e "\n${CYAN}═══ Deleting DNS Record ═══${NC}\n"
            echo "Name: $name"
            echo ""
            echo -e "${YELLOW}⚠${NC} This feature requires manual API access to DNS manager"
            echo ""
            echo "To delete, remove the record from services.yaml and run:"
            echo "  ./homelab dns sync"
            echo ""
            echo "Or manage directly via Cloudflare dashboard:"
            echo "  https://dash.cloudflare.com/"
            ;;
        
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: ./homelab dns [status|list|sync|create|delete]"
            echo ""
            echo "Commands:"
            echo "  status           - Show DNS manager health and status"
            echo "  list <zone>      - List all DNS records for a zone"
            echo "  sync             - Sync DNS records from services.yaml to Cloudflare"
            echo "  create <n> <t>   - Create DNS record (name, target)"
            echo "  delete <name>    - Delete DNS record"
            return 1
            ;;
    esac
}

# MAIN
# ============================================
case "${1:-help}" in
    fix|start)
        fix
        ;;
    status)
        status
        ;;
    logs)
        shift
        logs "$@"
        ;;
    debug)
        debug
        ;;
    health)
        shift
        health "$@"
        ;;
    validate-env)
        validate_env
        ;;
    backup)
        shift
        backup "$@"
        ;;
    restore)
        shift
        restore "$@"
        ;;
    update)
        update
        ;;
    rebuild)
        shift
        rebuild "$@"
        ;;
    clean)
        clean
        ;;
    db-shell)
        shift
        db_shell "$@"
        ;;
    test)
        test_services
        ;;
    deploy)
        shift
        deploy_service "$@"
        ;;
    pipeline)
        shift
        deploy_pipeline "$@"
        ;;
    undeploy)
        shift
        undeploy_service "$@"
        ;;
    services)
        shift
        services_cmd "$@"
        ;;
    routes)
        shift
        routes_cmd "$@"
        ;;
    network)
        shift
        network_cmd "$@"
        ;;
    db)
        shift
        db_cmd "$@"
        ;;
    config)
        shift
        case "${1:-help}" in
            generate)
                shift
                config_generate "$@"
                ;;
            validate)
                shift
                config_validate "$@"
                ;;
            encrypt)
                config_encrypt
                ;;
            *)
                config_help
                ;;
        esac
        ;;
    deploy-prod)
        shift
        "$PROJECT_ROOT/scripts/deploy.sh" "$@"
        ;;
    rollback)
        shift
        "$PROJECT_ROOT/scripts/rollback.sh" "$@"
        ;;
    deployment)
        shift
        deployment_cmd "$@"
        ;;
    metrics)
        metrics
        ;;
    alerts)
        alerts
        ;;
    gateway)
        shift
        gateway_cmd "$@"
        ;;
    dns)
        shift
        dns_cmd "$@"
        ;;
    restart)
        echo "Restarting all services..."
        compose restart
        ;;
    stop)
        compose down
        echo -e "${GREEN}✓ All services stopped${NC}"
        ;;
    doctor)
        shift
        if [ -f "$PROJECT_ROOT/homelab-doctor.sh" ]; then
            "$PROJECT_ROOT/homelab-doctor.sh" "${1:-human}"
        else
            echo -e "${RED}✗ homelab-doctor.sh not found${NC}"
            exit 1
        fi
        ;;
    check-deps|deps)
        if [ -f "$PROJECT_ROOT/check-dependencies.sh" ]; then
            "$PROJECT_ROOT/check-dependencies.sh" "$@"
        else
            echo -e "${RED}✗ check-dependencies.sh not found${NC}"
            exit 1
        fi
        ;;
    help|*)
        cat << 'EOF'
╔════════════════════════════════════════════════════════╗
║           HOMELAB - Production-Ready Management        ║
╚════════════════════════════════════════════════════════╝

Usage: ./homelab [command]

CORE COMMANDS:
  fix                   - Fix everything and start all services
  pipeline              - Unified deployment (validate + preflight + deploy + health check)
  pipeline --dry-run    - Preview deployment without making changes
  status                - Show which services are running
  logs [service]        - View logs (add service name for specific)
  logs --json [service] - Output logs in JSON format
  restart               - Restart all services
  stop                  - Stop everything

MODULAR DEPLOYMENT (Phase 2):
  deploy <target>       - Deploy service or group
  undeploy <target>     - Stop service or group
  services list         - List all available services & groups
  services deps <svc>   - Show service dependencies
  services catalog      - View full service catalog
  services discover     - Show services registered with Consul

SERVICE DISCOVERY (Phase 3):
  routes list           - Show Traefik routing configuration
  network status        - Show Tailscale network status
  network peers         - Show Tailscale network peers
  network routes        - Show Tailscale advertised routes

DATABASE MANAGEMENT (Phase 4):
  db status             - Show database platform status (postgres, pgbouncer, backups)
  db backup [type]      - Trigger manual backup (full, incremental, differential)
  db restore <id>       - Restore database from backup
  db list-backups       - List all available backups
  db migrate <service>  - Run migrations for specific service

OBSERVABILITY & MONITORING (Phase 5):
  metrics          - Open Grafana dashboards and show metrics status
  alerts           - Show active Prometheus alerts
  logs [service]   - Stream logs via Loki (Ctrl+C to exit)

API GATEWAY & AUTH (Phase 7):
  gateway status                 - Show gateway health and active routes
  gateway tokens                 - List registered service tokens
  gateway generate-token <svc>   - Generate new service authentication token
  gateway logs [--follow]        - View gateway access logs

DNS AUTOMATION (Phase 8):
  dns status           - Show DNS manager health and zones
  dns list <zone>      - List all DNS records for a zone
  dns sync             - Sync DNS records from services.yaml to Cloudflare
  dns create <n> <t>   - Create DNS record (name, target)
  dns delete <name>    - Delete DNS record

HEALTH & DIAGNOSTICS:
  health                - Basic health checks (DB, API, disk, memory)
  health --full         - Run comprehensive doctor diagnostics
  health --json         - Output diagnostics as JSON
  doctor [human|json]   - Full system diagnostics with JSON report
  validate-env          - Check .env has all required variables
  check-deps            - Verify all system dependencies
  debug                 - Show detailed debugging info
  test                  - Run integration tests on all services

DEPLOYMENT & CI/CD (Phase 6):
  deploy-prod <service>       - Deploy service to production with health checks
  rollback <service> [backup] - Rollback service to previous version
  deployment history          - Show deployment history (last 10)
  deployment status           - Show current deployment status

OPERATIONS:
  backup              - Backup all databases to timestamped files
  backup --full       - Complete system backup (DB + configs)
  restore <file>      - Restore from backup
  update              - Git pull and redeploy (for production)
  rebuild <svc>       - Rebuild and restart specific service
  clean               - Clean old logs, unused containers/images
  db-shell [db]       - Quick PostgreSQL shell access

CONFIGURATION MANAGEMENT:
  config generate <env> <host>  - Generate encrypted configs
  config validate <env> <host>  - Validate generated configs
  config encrypt                - Encrypt secrets with SOPS
  config help                   - Show config management help

EXAMPLES:
  ./homelab fix                    # Fix all issues
  ./homelab deploy dashboard       # Deploy just dashboard
  ./homelab deploy bots            # Deploy Discord + Stream bots
  ./homelab deploy core            # Deploy infrastructure only
  ./homelab undeploy discord-bot   # Stop Discord bot
  ./homelab services list          # List available services
  ./homelab services deps dashboard # Show dashboard dependencies
  ./homelab health                 # Run basic health checks
  ./homelab health --full          # Run comprehensive diagnostics
  ./homelab doctor json            # Generate JSON diagnostic report
  ./homelab validate-env           # Check environment variables
  ./homelab backup                 # Backup databases
  ./homelab backup --full          # Full system backup (DB + configs)
  ./homelab restore backup.sql     # Restore from backup
  ./homelab update                 # Update from git
  ./homelab rebuild discord-bot    # Rebuild specific service
  ./homelab clean                  # Cleanup old files
  ./homelab db-shell homelab_jarvis  # Access database
  ./homelab test                   # Run integration tests
  ./homelab logs homelab-dashboard   # View dashboard logs
  ./homelab logs --json              # Output logs in JSON format

MODULAR ARCHITECTURE:
  Services are now modular - deploy only what you need!
  - core: postgres, redis, minio, caddy, traefik, auth-service
  - bots: discord-bot, stream-bot
  - web: n8n, homeassistant, static sites
  - automation: celery-worker
  - development: vnc-desktop, code-server
  - observability: prometheus, grafana, loki, watchtower (Phase 5)

  See orchestration/README.md for architecture details

DOCUMENTATION:
  See OPERATIONS_GUIDE.md for detailed procedures
  See orchestration/README.md for modular deployment guide

The key: This script uses ABSOLUTE PATHS so Docker finds
your .env file and configurations correctly.

Run on your Ubuntu server at: /home/evin/contain/HomeLabHub
EOF
        ;;
esac
