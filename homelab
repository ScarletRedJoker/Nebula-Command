#!/bin/bash
# ╔════════════════════════════════════════════════════════════════╗
# ║              HOMELAB - PRODUCTION-READY MANAGEMENT            ║
# ╚════════════════════════════════════════════════════════════════╝

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# Auto-detect project root
if [ -d "/home/evin/contain/HomeLabHub" ]; then
    # On Ubuntu server
    PROJECT_ROOT="/home/evin/contain/HomeLabHub"
else
    # In development/Replit
    PROJECT_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
fi

ENV_FILE="$PROJECT_ROOT/.env"
COMPOSE_FILE="$PROJECT_ROOT/docker-compose.yml"

echo -e "${CYAN}Project Root: $PROJECT_ROOT${NC}"

# Verify files exist
if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}ERROR: .env file not found at $ENV_FILE${NC}"
    echo "Run this script from your Ubuntu server at /home/evin/contain/HomeLabHub"
    exit 1
fi

if [ ! -f "$COMPOSE_FILE" ]; then
    echo -e "${RED}ERROR: docker-compose.yml not found at $COMPOSE_FILE${NC}"
    exit 1
fi

# Docker Compose command with ABSOLUTE PATHS
compose() {
    docker compose \
        --project-directory "$PROJECT_ROOT" \
        --env-file "$ENV_FILE" \
        -f "$COMPOSE_FILE" \
        "$@"
}

# Service list
ALL_SERVICES=(
    "homelab-postgres" "homelab-redis" "homelab-minio"
    "homelab-dashboard" "homelab-celery-worker"
    "discord-bot" "stream-bot"
    "caddy" "vnc-desktop" "code-server"
    "plex-server" "n8n" "homeassistant"
    "rig-city-site" "scarletredjoker-web"
)

# Check if service is running
is_running() {
    docker ps --format "{{.Names}}" | grep -q "^$1$"
}

# Count running services
count_running() {
    local count=0
    for service in "${ALL_SERVICES[@]}"; do
        is_running "$service" && ((count++))
    done
    echo $count
}

# ============================================
# FIX COMMAND - Simple and Effective
# ============================================
fix() {
    echo -e "${CYAN}═══ FIXING HOMELAB ═══${NC}\n"
    
    echo "Project: $PROJECT_ROOT"
    echo "Env File: $ENV_FILE"
    echo ""
    
    # Rebuild bots with --no-cache to pick up password changes
    echo -e "${CYAN}[1/4] Rebuilding bots without cache (ensures password changes are applied)...${NC}"
    compose build --no-cache discord-bot stream-bot
    
    # Force recreate ALL containers with correct environment
    echo -e "${CYAN}[2/4] Force recreating all services with environment...${NC}"
    compose up -d --force-recreate
    
    echo -e "${CYAN}[3/4] Waiting for stability...${NC}"
    sleep 10
    
    # Create databases if PostgreSQL is ready
    echo -e "${CYAN}[4/4] Setting up databases...${NC}"
    if docker exec homelab-postgres pg_isready -U postgres &>/dev/null; then
        for db in ticketbot streambot homelab_jarvis; do
            if ! docker exec homelab-postgres psql -U postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw "$db"; then
                echo "  Creating database: $db"
                docker exec homelab-postgres psql -U postgres -c "CREATE DATABASE $db;" 2>/dev/null || true
            fi
        done
        echo -e "${GREEN}✓ Databases ready${NC}"
    fi
    
    # Status
    local running=$(count_running)
    echo ""
    if [ $running -eq 15 ]; then
        echo -e "${GREEN}✅ SUCCESS! All 15/15 services running!${NC}"
    else
        echo -e "${YELLOW}⚠ $running/15 services running${NC}"
        echo "Check logs: ./homelab logs"
    fi
}

# ============================================
# STATUS COMMAND
# ============================================
status() {
    echo -e "\n${CYAN}═══ Service Status ═══${NC}\n"
    
    local running=0
    for service in "${ALL_SERVICES[@]}"; do
        if is_running "$service"; then
            echo -e "$service: ${GREEN}● Running${NC}"
            ((running++))
        else
            echo -e "$service: ${RED}○ Stopped${NC}"
        fi
    done
    
    echo ""
    if [ $running -eq 15 ]; then
        echo -e "${GREEN}✅ All 15/15 services running${NC}"
    else
        echo -e "${YELLOW}⚠ $running/15 services running${NC}"
    fi
}

# ============================================
# LOGS COMMAND with Auto-Save
# ============================================
logs() {
    mkdir -p "$PROJECT_ROOT/logs"
    local timestamp=$(date +%Y%m%d-%H%M%S)
    
    if [ $# -eq 0 ]; then
        # All services
        echo -e "${CYAN}Showing logs for all services...${NC}"
        compose logs --tail=100 -f | tee "$PROJECT_ROOT/logs/all-services-$timestamp.log"
    else
        # Specific service
        echo -e "${CYAN}Showing logs for $1...${NC}"
        compose logs --tail=100 -f "$1" | tee "$PROJECT_ROOT/logs/$1-$timestamp.log"
    fi
}

# ============================================
# DEBUG COMMAND - Show What Docker Sees
# ============================================
debug() {
    echo -e "${CYAN}═══ Debug Information ═══${NC}\n"
    
    echo "Project Root: $PROJECT_ROOT"
    echo "Current Dir: $(pwd)"
    echo ""
    
    echo -e "${CYAN}Checking .env file:${NC}"
    if [ -f "$ENV_FILE" ]; then
        echo -e "${GREEN}✓ .env exists${NC}"
        echo "  Variables loaded:"
        grep -c "=" "$ENV_FILE" | xargs echo "  "
        echo ""
        echo "  Checking critical variables:"
        grep "^WEB_USERNAME=" "$ENV_FILE" || echo -e "  ${RED}✗ WEB_USERNAME missing${NC}"
        grep "^WEB_PASSWORD=" "$ENV_FILE" || echo -e "  ${RED}✗ WEB_PASSWORD missing${NC}"
        grep "^POSTGRES_PASSWORD=" "$ENV_FILE" || echo -e "  ${RED}✗ POSTGRES_PASSWORD missing${NC}"
    else
        echo -e "${RED}✗ .env NOT FOUND${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}Checking homelab-dashboard container environment:${NC}"
    if is_running "homelab-dashboard"; then
        echo "  WEB_USERNAME in container:"
        docker exec homelab-dashboard env | grep "WEB_USERNAME" || echo -e "  ${RED}✗ NOT SET${NC}"
        echo "  POSTGRES_PASSWORD in container:"
        docker exec homelab-dashboard env | grep "POSTGRES_PASSWORD" || echo -e "  ${RED}✗ NOT SET${NC}"
    else
        echo -e "${YELLOW}  Dashboard not running${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}Service Status:${NC}"
    status
}

# ============================================
# HEALTH COMMAND - Comprehensive Health Checks
# ============================================
health() {
    echo -e "\n${CYAN}═══ Comprehensive Health Check ═══${NC}\n"
    
    local health_issues=0
    
    # 1. Database Connectivity
    echo -e "${CYAN}[1/5] Database Connections${NC}"
    if is_running "homelab-postgres"; then
        if docker exec homelab-postgres pg_isready -U postgres &>/dev/null; then
            echo -e "  ${GREEN}✓${NC} PostgreSQL responding"
            
            # Check each database
            for db in ticketbot streambot homelab_jarvis; do
                if docker exec homelab-postgres psql -U postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw "$db"; then
                    echo -e "  ${GREEN}✓${NC} Database: $db"
                else
                    echo -e "  ${RED}✗${NC} Database missing: $db"
                    ((health_issues++))
                fi
            done
        else
            echo -e "  ${RED}✗${NC} PostgreSQL not responding"
            ((health_issues++))
        fi
    else
        echo -e "  ${RED}✗${NC} PostgreSQL container not running"
        ((health_issues++))
    fi
    
    # 2. API Endpoint Tests
    echo -e "\n${CYAN}[2/5] API Endpoints${NC}"
    test_endpoint() {
        local name=$1
        local url=$2
        local expected_codes=$3
        
        local status=$(curl -s -o /dev/null -w "%{http_code}" "$url" 2>/dev/null || echo "000")
        if echo "$expected_codes" | grep -q "$status"; then
            echo -e "  ${GREEN}✓${NC} $name (HTTP $status)"
        else
            echo -e "  ${RED}✗${NC} $name (HTTP $status, expected: $expected_codes)"
            ((health_issues++))
        fi
    }
    
    test_endpoint "Dashboard" "http://localhost:8080/" "200 302"
    test_endpoint "Discord Bot" "http://localhost:4000/health" "200 302 404"
    test_endpoint "Stream Bot" "http://localhost:5000/health" "200 302 404"
    test_endpoint "MinIO" "http://localhost:9000/minio/health/live" "200"
    
    # 3. Disk Space
    echo -e "\n${CYAN}[3/5] Disk Space${NC}"
    local disk_usage=$(df -h "$PROJECT_ROOT" | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ "$disk_usage" -lt 80 ]; then
        echo -e "  ${GREEN}✓${NC} Disk usage: ${disk_usage}%"
    elif [ "$disk_usage" -lt 90 ]; then
        echo -e "  ${YELLOW}⚠${NC} Disk usage: ${disk_usage}% (warning)"
        ((health_issues++))
    else
        echo -e "  ${RED}✗${NC} Disk usage: ${disk_usage}% (critical)"
        ((health_issues++))
    fi
    
    # 4. Memory Usage
    echo -e "\n${CYAN}[4/5] Memory Usage${NC}"
    local mem_available=$(free -m | awk 'NR==2 {print $7}')
    local mem_total=$(free -m | awk 'NR==2 {print $2}')
    local mem_percent=$((100 - (mem_available * 100 / mem_total)))
    
    if [ "$mem_percent" -lt 80 ]; then
        echo -e "  ${GREEN}✓${NC} Memory usage: ${mem_percent}%"
    elif [ "$mem_percent" -lt 90 ]; then
        echo -e "  ${YELLOW}⚠${NC} Memory usage: ${mem_percent}% (warning)"
    else
        echo -e "  ${RED}✗${NC} Memory usage: ${mem_percent}% (critical)"
        ((health_issues++))
    fi
    
    # 5. Container Health Status
    echo -e "\n${CYAN}[5/5] Container Health Status${NC}"
    for service in "${ALL_SERVICES[@]}"; do
        if is_running "$service"; then
            local health_status=$(docker inspect "$service" --format='{{.State.Health.Status}}' 2>/dev/null || echo "no-healthcheck")
            if [ "$health_status" = "healthy" ] || [ "$health_status" = "no-healthcheck" ]; then
                echo -e "  ${GREEN}✓${NC} $service"
            elif [ "$health_status" = "starting" ]; then
                echo -e "  ${YELLOW}⟳${NC} $service (starting)"
            else
                echo -e "  ${RED}✗${NC} $service ($health_status)"
                ((health_issues++))
            fi
        else
            echo -e "  ${RED}○${NC} $service (not running)"
            ((health_issues++))
        fi
    done
    
    # Summary
    echo ""
    if [ $health_issues -eq 0 ]; then
        echo -e "${GREEN}✅ All health checks passed!${NC}"
        return 0
    else
        echo -e "${RED}⚠ Found $health_issues health issue(s)${NC}"
        echo "Run './homelab fix' to attempt automatic repair"
        return 1
    fi
}

# ============================================
# VALIDATE-ENV COMMAND - Environment Validation
# ============================================
validate_env() {
    echo -e "\n${CYAN}═══ Environment Validation ═══${NC}\n"
    
    if [ ! -f "$ENV_FILE" ]; then
        echo -e "${RED}✗ .env file not found at $ENV_FILE${NC}"
        echo "Create it from template: cp .env.example .env"
        return 1
    fi
    
    echo "Checking required variables..."
    echo ""
    
    local required_vars=(
        "POSTGRES_PASSWORD"
        "DISCORD_DB_PASSWORD"
        "STREAMBOT_DB_PASSWORD"
        "JARVIS_DB_PASSWORD"
        "WEB_USERNAME"
        "WEB_PASSWORD"
        "SESSION_SECRET"
        "DISCORD_BOT_TOKEN"
        "DISCORD_CLIENT_ID"
        "DISCORD_CLIENT_SECRET"
        "OPENAI_API_KEY"
    )
    
    local missing_vars=()
    local present_vars=()
    
    for var in "${required_vars[@]}"; do
        if grep -q "^${var}=" "$ENV_FILE" && [ -n "$(grep "^${var}=" "$ENV_FILE" | cut -d'=' -f2)" ]; then
            echo -e "  ${GREEN}✓${NC} $var"
            present_vars+=("$var")
        else
            echo -e "  ${RED}✗${NC} $var - MISSING or EMPTY"
            missing_vars+=("$var")
        fi
    done
    
    echo ""
    echo "Summary: ${#present_vars[@]}/${#required_vars[@]} required variables present"
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        echo ""
        echo -e "${RED}Missing variables:${NC}"
        for var in "${missing_vars[@]}"; do
            echo "  - $var"
        done
        echo ""
        echo "Update your .env file before deployment"
        return 1
    else
        echo -e "\n${GREEN}✅ All required variables present${NC}"
        return 0
    fi
}

# ============================================
# BACKUP COMMAND - Database Backups
# ============================================
backup() {
    echo -e "\n${CYAN}═══ Database Backup ═══${NC}\n"
    
    if ! is_running "homelab-postgres"; then
        echo -e "${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    # Create backups directory with secure permissions
    local backup_dir="$PROJECT_ROOT/backups"
    mkdir -p "$backup_dir"
    chmod 700 "$backup_dir"
    
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_file="$backup_dir/homelab-backup-$timestamp.sql"
    
    echo "Backing up all databases to:"
    echo "  $backup_file"
    echo ""
    
    # Extract PostgreSQL password from .env (secure method)
    local POSTGRES_PASSWORD=$(grep "^POSTGRES_PASSWORD=" "$ENV_FILE" | cut -d'=' -f2-)
    
    if [ -z "$POSTGRES_PASSWORD" ]; then
        echo -e "${RED}✗ POSTGRES_PASSWORD not found in .env${NC}"
        return 1
    fi
    
    # Backup all databases using PGPASSWORD (no credentials in process list)
    if PGPASSWORD="$POSTGRES_PASSWORD" docker exec homelab-postgres \
        pg_dumpall -U postgres > "$backup_file"; then
        
        # Set secure permissions on backup file (owner read/write only)
        chmod 600 "$backup_file"
        
        local size=$(du -h "$backup_file" | cut -f1)
        echo -e "${GREEN}✅ Backup created successfully${NC}"
        echo "  Size: $size"
        echo "  File: $(basename $backup_file)"
        echo "  Permissions: 600 (secure)"
        echo ""
        echo "To restore: ./homelab restore $backup_file"
        
        # Keep only last 10 backups
        cd "$backup_dir"
        ls -t homelab-backup-*.sql 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null
        local backup_count=$(ls -1 homelab-backup-*.sql 2>/dev/null | wc -l)
        echo "  Backups retained: $backup_count"
        
        # Clear password from environment
        unset POSTGRES_PASSWORD
        return 0
    else
        echo -e "${RED}✗ Backup failed${NC}"
        rm -f "$backup_file"
        unset POSTGRES_PASSWORD
        return 1
    fi
}

# ============================================
# RESTORE COMMAND - Database Restore
# ============================================
restore() {
    local input_file="$1"
    
    # Whitelist: Only allow backups from secure directory
    local BACKUPS_DIR="$PROJECT_ROOT/backups"
    
    if [ -z "$input_file" ]; then
        echo -e "${RED}✗ Usage: ./homelab restore <backup-file>${NC}"
        echo ""
        echo "Available backups:"
        if [ -d "$BACKUPS_DIR" ]; then
            ls -1t "$BACKUPS_DIR/"homelab-backup-*.sql 2>/dev/null | head -5 | while read f; do
                echo "  $(basename $f) ($(du -h "$f" | cut -f1))"
            done
        else
            echo "  No backups found in $BACKUPS_DIR"
        fi
        return 1
    fi
    
    # Convert to absolute path for validation
    local backup_file
    if [[ "$input_file" = /* ]]; then
        backup_file="$input_file"
    else
        backup_file="$(cd "$(dirname "$input_file")" 2>/dev/null && pwd)/$(basename "$input_file")"
    fi
    
    # SECURITY: Validate file path is in whitelisted directory (no traversal)
    if [[ "$backup_file" != "$BACKUPS_DIR"/* ]]; then
        echo -e "${RED}✗ SECURITY: Backup file must be in $BACKUPS_DIR${NC}"
        echo "  Provided: $backup_file"
        echo "  Required: $BACKUPS_DIR/"
        return 1
    fi
    
    # SECURITY: Verify file exists and is a regular file (not symlink, device, etc.)
    if [ ! -f "$backup_file" ] || [ ! -r "$backup_file" ]; then
        echo -e "${RED}✗ Backup file not found or not readable: $backup_file${NC}"
        return 1
    fi
    
    # Detect if file is a symbolic link (additional security)
    if [ -L "$backup_file" ]; then
        echo -e "${RED}✗ SECURITY: Symbolic links are not allowed${NC}"
        return 1
    fi
    
    # SECURITY: Check file size constraints (min 1KB, max 10GB)
    local size
    # Use stat (works on both macOS and Linux)
    size=$(stat -f%z "$backup_file" 2>/dev/null || stat -c%s "$backup_file" 2>/dev/null)
    
    if [ -z "$size" ]; then
        echo -e "${RED}✗ Could not determine file size${NC}"
        return 1
    fi
    
    local min_size=1024          # 1KB minimum
    local max_size=10737418240   # 10GB maximum
    
    if [ "$size" -lt "$min_size" ]; then
        echo -e "${RED}✗ Backup file too small (${size} bytes, minimum ${min_size} bytes)${NC}"
        echo "  File may be corrupted or empty"
        return 1
    fi
    
    if [ "$size" -gt "$max_size" ]; then
        echo -e "${RED}✗ Backup file too large (${size} bytes, maximum ${max_size} bytes)${NC}"
        echo "  File may be corrupted or malicious"
        return 1
    fi
    
    # Show details and get confirmation
    echo -e "\n${CYAN}═══ Database Restore ═══${NC}\n"
    echo -e "${YELLOW}⚠ WARNING: This will REPLACE all current databases!${NC}"
    echo ""
    echo "Backup file: $(basename $backup_file)"
    echo "Location: $backup_file"
    echo "Size: $(du -h "$backup_file" | cut -f1) ($(numfmt --to=iec-i --suffix=B $size 2>/dev/null || echo "${size} bytes"))"
    echo "Modified: $(stat -f%Sm "$backup_file" 2>/dev/null || stat -c%y "$backup_file" 2>/dev/null)"
    echo ""
    echo "Services that will be stopped:"
    echo "  - homelab-dashboard"
    echo "  - homelab-celery-worker"
    echo "  - discord-bot"
    echo "  - stream-bot"
    echo ""
    read -p "Type 'yes' to continue: " confirm
    
    if [ "$confirm" != "yes" ]; then
        echo "Restore cancelled"
        return 0
    fi
    
    if ! is_running "homelab-postgres"; then
        echo -e "\n${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    # Stop all services that use the database
    echo -e "\n${CYAN}Stopping dependent services...${NC}"
    compose stop homelab-dashboard homelab-celery-worker discord-bot stream-bot
    sleep 3
    
    # Extract PostgreSQL password from .env (secure method)
    local POSTGRES_PASSWORD=$(grep "^POSTGRES_PASSWORD=" "$ENV_FILE" | cut -d'=' -f2-)
    
    if [ -z "$POSTGRES_PASSWORD" ]; then
        echo -e "${RED}✗ POSTGRES_PASSWORD not found in .env${NC}"
        echo "Restarting services..."
        compose start homelab-dashboard homelab-celery-worker discord-bot stream-bot
        return 1
    fi
    
    # Restore with PGPASSWORD (no credentials in process list)
    echo -e "${CYAN}Restoring databases from backup...${NC}"
    if PGPASSWORD="$POSTGRES_PASSWORD" docker exec -i homelab-postgres \
        psql -U postgres < "$backup_file"; then
        
        # Clear password from environment
        unset POSTGRES_PASSWORD
        
        echo -e "\n${GREEN}✅ Restore completed successfully${NC}"
        echo ""
        echo -e "${CYAN}Restarting services...${NC}"
        compose start homelab-dashboard homelab-celery-worker discord-bot stream-bot
        sleep 5
        
        echo ""
        echo -e "${GREEN}✅ All services restarted${NC}"
        echo "Run './homelab status' to verify services"
        return 0
    else
        # Clear password from environment
        unset POSTGRES_PASSWORD
        
        echo -e "\n${RED}✗ Restore failed${NC}"
        echo -e "${YELLOW}⚠ Services have been stopped for safety${NC}"
        echo ""
        echo "Manual recovery steps:"
        echo "  1. Check logs: docker logs homelab-postgres"
        echo "  2. Verify backup file integrity"
        echo "  3. Restore from another backup"
        echo "  4. Or restart services: ./homelab start"
        return 1
    fi
}

# ============================================
# UPDATE COMMAND - Git Pull and Redeploy
# ============================================
update() {
    echo -e "\n${CYAN}═══ Update Deployment ═══${NC}\n"
    
    cd "$PROJECT_ROOT"
    
    # Check if git repo
    if [ ! -d ".git" ]; then
        echo -e "${RED}✗ Not a git repository${NC}"
        return 1
    fi
    
    # Create backup before update
    echo "Creating pre-update backup..."
    backup
    
    # Fetch updates
    echo ""
    echo "Fetching latest changes..."
    git fetch origin
    
    # Show what would change
    local changes=$(git rev-list HEAD..origin/main --count 2>/dev/null || echo "0")
    
    if [ "$changes" = "0" ]; then
        echo -e "${GREEN}✓ Already up to date${NC}"
        return 0
    fi
    
    echo ""
    echo -e "${YELLOW}$changes commit(s) to pull${NC}"
    git log --oneline HEAD..origin/main | head -5
    echo ""
    read -p "Continue with update? (y/N): " confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Update cancelled"
        return 0
    fi
    
    # Pull changes
    echo ""
    echo "Pulling changes..."
    git pull origin main
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}✗ Git pull failed${NC}"
        echo "Resolve conflicts manually, then run './homelab fix'"
        return 1
    fi
    
    # Rebuild and restart
    echo ""
    echo "Rebuilding and redeploying..."
    compose build
    compose up -d --force-recreate
    
    echo ""
    echo -e "${GREEN}✅ Update completed${NC}"
    echo "Run './homelab health' to verify deployment"
}

# ============================================
# REBUILD COMMAND - Rebuild Specific Service
# ============================================
rebuild() {
    local service="$1"
    
    if [ -z "$service" ]; then
        echo -e "${RED}✗ Usage: ./homelab rebuild <service>${NC}"
        echo ""
        echo "Available services:"
        for svc in "${ALL_SERVICES[@]}"; do
            echo "  - $svc"
        done
        return 1
    fi
    
    echo -e "\n${CYAN}═══ Rebuilding $service ═══${NC}\n"
    
    # Verify service exists in compose
    local compose_service="${service#homelab-}"
    if ! compose config --services 2>/dev/null | grep -q "^${compose_service}$"; then
        echo -e "${RED}✗ Service not found in docker-compose.yml${NC}"
        return 1
    fi
    
    # Rebuild
    echo "Building $compose_service..."
    compose build --no-cache "$compose_service"
    
    if [ $? -eq 0 ]; then
        echo ""
        echo "Recreating container..."
        compose up -d --force-recreate "$compose_service"
        
        echo ""
        echo -e "${GREEN}✅ Rebuild completed${NC}"
        echo "Check logs: ./homelab logs $service"
    else
        echo -e "\n${RED}✗ Rebuild failed${NC}"
        return 1
    fi
}

# ============================================
# CLEAN COMMAND - Cleanup Old Resources
# ============================================
clean() {
    echo -e "\n${CYAN}═══ Cleanup ═══${NC}\n"
    
    local cleaned=0
    
    # 1. Old log files
    echo -e "${CYAN}[1/4] Cleaning old logs${NC}"
    local log_dirs=("$PROJECT_ROOT/logs" "$PROJECT_ROOT/services/dashboard/logs" "$PROJECT_ROOT/services/discord-bot/logs" "$PROJECT_ROOT/services/stream-bot/logs")
    
    for dir in "${log_dirs[@]}"; do
        if [ -d "$dir" ]; then
            # Keep logs from last 7 days, delete older
            local deleted=$(find "$dir" -name "*.log" -type f -mtime +7 -delete -print 2>/dev/null | wc -l)
            if [ "$deleted" -gt 0 ]; then
                echo "  Removed $deleted log file(s) from $(basename $dir)"
                ((cleaned++))
            fi
        fi
    done
    
    if [ $cleaned -eq 0 ]; then
        echo "  No old logs to remove"
    fi
    
    # 2. Old backups
    echo -e "\n${CYAN}[2/4] Cleaning old backups${NC}"
    local backup_dir="$PROJECT_ROOT/backups"
    if [ -d "$backup_dir" ]; then
        cd "$backup_dir"
        # Keep last 10 backups
        local old_backups=$(ls -t homelab-backup-*.sql 2>/dev/null | tail -n +11)
        if [ -n "$old_backups" ]; then
            echo "$old_backups" | xargs rm -f
            local count=$(echo "$old_backups" | wc -l)
            echo "  Removed $count old backup(s)"
        else
            echo "  No old backups to remove"
        fi
    else
        echo "  No backup directory found"
    fi
    
    # 3. Unused Docker images
    echo -e "\n${CYAN}[3/4] Cleaning unused Docker images${NC}"
    docker image prune -f | grep -E "^(Total|Deleted)" || echo "  No unused images"
    
    # 4. Stopped containers
    echo -e "\n${CYAN}[4/4] Cleaning stopped containers${NC}"
    docker container prune -f | grep -E "^(Total|Deleted)" || echo "  No stopped containers"
    
    echo ""
    echo -e "${GREEN}✅ Cleanup completed${NC}"
}

# ============================================
# DB-SHELL COMMAND - PostgreSQL Shell Access
# ============================================
db_shell() {
    local database="${1:-postgres}"
    
    echo -e "${CYAN}═══ PostgreSQL Shell ═══${NC}\n"
    
    if ! is_running "homelab-postgres"; then
        echo -e "${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    echo "Connecting to database: $database"
    echo "Type '\q' or Ctrl+D to exit"
    echo ""
    
    docker exec -it homelab-postgres psql -U postgres -d "$database"
}

# ============================================
# TEST COMMAND - Integration Tests
# ============================================
test_services() {
    echo -e "\n${CYAN}═══ Integration Tests ═══${NC}\n"
    
    local tests_passed=0
    local tests_failed=0
    
    # Test 1: Database Connectivity
    echo -e "${CYAN}[1/6] Database Connectivity${NC}"
    if docker exec homelab-postgres psql -U postgres -c "SELECT 1" &>/dev/null; then
        echo -e "  ${GREEN}✓ PASS${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL${NC}"
        ((tests_failed++))
    fi
    
    # Test 2: Dashboard API
    echo -e "\n${CYAN}[2/6] Dashboard API${NC}"
    local dash_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ 2>/dev/null || echo "000")
    if [ "$dash_status" = "200" ] || [ "$dash_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $dash_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL (HTTP $dash_status)${NC}"
        ((tests_failed++))
    fi
    
    # Test 3: Discord Bot
    echo -e "\n${CYAN}[3/6] Discord Bot${NC}"
    local discord_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:4000/ 2>/dev/null || echo "000")
    if [ "$discord_status" = "200" ] || [ "$discord_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $discord_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${YELLOW}⚠ SKIP (HTTP $discord_status)${NC} - Service may not have /health endpoint"
        ((tests_passed++))  # Don't fail on this
    fi
    
    # Test 4: Stream Bot
    echo -e "\n${CYAN}[4/6] Stream Bot${NC}"
    local stream_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/ 2>/dev/null || echo "000")
    if [ "$stream_status" = "200" ] || [ "$stream_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $stream_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${YELLOW}⚠ SKIP (HTTP $stream_status)${NC} - Service may not have /health endpoint"
        ((tests_passed++))  # Don't fail on this
    fi
    
    # Test 5: Redis Connection
    echo -e "\n${CYAN}[5/6] Redis Connection${NC}"
    if docker exec homelab-redis redis-cli ping 2>/dev/null | grep -q "PONG"; then
        echo -e "  ${GREEN}✓ PASS${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL${NC}"
        ((tests_failed++))
    fi
    
    # Test 6: MinIO Health
    echo -e "\n${CYAN}[6/6] MinIO Health${NC}"
    local minio_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9000/minio/health/live 2>/dev/null || echo "000")
    if [ "$minio_status" = "200" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $minio_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL (HTTP $minio_status)${NC}"
        ((tests_failed++))
    fi
    
    # Summary
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Results: $tests_passed passed, $tests_failed failed"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    if [ $tests_failed -eq 0 ]; then
        echo -e "${GREEN}✅ All tests passed!${NC}"
        return 0
    else
        echo -e "${RED}⚠ Some tests failed${NC}"
        return 1
    fi
}

# ============================================
# MAIN
# ============================================
case "${1:-help}" in
    fix|start)
        fix
        ;;
    status)
        status
        ;;
    logs)
        shift
        logs "$@"
        ;;
    debug)
        debug
        ;;
    health)
        health
        ;;
    validate-env)
        validate_env
        ;;
    backup)
        backup
        ;;
    restore)
        shift
        restore "$@"
        ;;
    update)
        update
        ;;
    rebuild)
        shift
        rebuild "$@"
        ;;
    clean)
        clean
        ;;
    db-shell)
        shift
        db_shell "$@"
        ;;
    test)
        test_services
        ;;
    restart)
        echo "Restarting all services..."
        compose restart
        ;;
    stop)
        compose down
        echo -e "${GREEN}✓ All services stopped${NC}"
        ;;
    help|*)
        cat << 'EOF'
╔════════════════════════════════════════════════════════╗
║           HOMELAB - Production-Ready Management        ║
╚════════════════════════════════════════════════════════╝

Usage: ./homelab [command]

CORE COMMANDS:
  fix              - Fix everything and start all services
  status           - Show which services are running
  logs [service]   - View logs (add service name for specific)
  restart          - Restart all services
  stop             - Stop everything

HEALTH & DIAGNOSTICS:
  health           - Comprehensive health checks (DB, API, disk, memory)
  validate-env     - Check .env has all required variables
  debug            - Show detailed debugging info
  test             - Run integration tests on all services

OPERATIONS:
  backup           - Backup all databases to timestamped files
  restore <file>   - Restore from backup
  update           - Git pull and redeploy (for production)
  rebuild <svc>    - Rebuild and restart specific service
  clean            - Clean old logs, unused containers/images
  db-shell [db]    - Quick PostgreSQL shell access

EXAMPLES:
  ./homelab fix                    # Fix all issues
  ./homelab health                 # Run health checks
  ./homelab validate-env           # Check environment variables
  ./homelab backup                 # Backup databases
  ./homelab restore backup.sql     # Restore from backup
  ./homelab update                 # Update from git
  ./homelab rebuild discord-bot    # Rebuild specific service
  ./homelab clean                  # Cleanup old files
  ./homelab db-shell homelab_jarvis  # Access database
  ./homelab test                   # Run integration tests
  ./homelab logs homelab-dashboard # View dashboard logs

DOCUMENTATION:
  See OPERATIONS_GUIDE.md for detailed procedures

The key: This script uses ABSOLUTE PATHS so Docker finds
your .env file and configurations correctly.

Run on your Ubuntu server at: /home/evin/contain/HomeLabHub
EOF
        ;;
esac
