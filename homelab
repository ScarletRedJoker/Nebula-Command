#!/bin/bash

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë         HOMELAB UNIFIED PLATFORM - COMPLETE SOLUTION          ‚ïë
# ‚ïë           ONE SCRIPT TO RULE THEM ALL v3.0                    ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'

# Configuration
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"

# Track issues and fixes
ISSUES_FOUND=0
ISSUES_FIXED=0
SERVICES_EXPECTED=15
SERVICES_RUNNING=0

# ============================================
# AUTOMATIC STARTUP WITH FULL FIXES
# ============================================

auto_startup() {
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë       HOMELAB AUTOMATIC STARTUP & FIX SYSTEM                  ‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    
    # Phase 1: Environment Setup
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ Phase 1: Environment Setup ‚îÅ‚îÅ‚îÅ${NC}"
    setup_environment
    
    # Phase 2: Cleanup & Preparation
    echo -e "\n${BLUE}‚îÅ‚îÅ‚îÅ Phase 2: Cleanup & Preparation ‚îÅ‚îÅ‚îÅ${NC}"
    cleanup_system
    
    # Phase 3: Database Setup
    echo -e "\n${BLUE}‚îÅ‚îÅ‚îÅ Phase 3: Database Setup ‚îÅ‚îÅ‚îÅ${NC}"
    setup_database
    
    # Phase 4: Build & Deploy
    echo -e "\n${BLUE}‚îÅ‚îÅ‚îÅ Phase 4: Build & Deploy Services ‚îÅ‚îÅ‚îÅ${NC}"
    deploy_all_services
    
    # Phase 5: Health Checks & Fixes
    echo -e "\n${BLUE}‚îÅ‚îÅ‚îÅ Phase 5: Health Checks & Auto-Fix ‚îÅ‚îÅ‚îÅ${NC}"
    perform_health_checks
    auto_fix_issues
    
    # Phase 6: Final Verification
    echo -e "\n${BLUE}‚îÅ‚îÅ‚îÅ Phase 6: Final Verification ‚îÅ‚îÅ‚îÅ${NC}"
    final_verification
    
    # Summary
    show_summary
}

# ============================================
# SETUP FUNCTIONS
# ============================================

setup_environment() {
    # Check if .env exists
    if [ ! -f .env ]; then
        echo -e "${YELLOW}‚ö† No .env file found. Starting interactive setup...${NC}"
        interactive_env_setup
    else
        # Load environment
        set -a
        source .env
        set +a
        echo -e "${GREEN}‚úì Environment loaded${NC}"
        
        # Validate critical variables
        validate_env_vars
    fi
}

interactive_env_setup() {
    echo -e "\n${CYAN}‚ïê‚ïê‚ïê Interactive Environment Setup ‚ïê‚ïê‚ïê${NC}\n"
    
    # Create .env from template or scratch
    if [ -f .env.example ]; then
        cp .env.example .env
        echo -e "${GREEN}‚úì Created .env from template${NC}"
    else
        touch .env
        echo -e "${GREEN}‚úì Created new .env file${NC}"
    fi
    
    # Interactive prompts for required values
    echo -e "\n${BOLD}Enter your configuration:${NC}\n"
    
    # OpenAI API Key (required for Jarvis)
    echo -ne "${CYAN}OpenAI API Key${NC} (for Jarvis AI): "
    read -r openai_key
    if [ ! -z "$openai_key" ]; then
        echo "OPENAI_API_KEY=$openai_key" >> .env
    fi
    
    # Discord Bot Token
    echo -ne "${CYAN}Discord Bot Token${NC} (leave empty to skip): "
    read -r discord_token
    if [ ! -z "$discord_token" ]; then
        echo "DISCORD_BOT_TOKEN=$discord_token" >> .env
    fi
    
    # Database URL (Neon)
    echo -ne "${CYAN}Neon Database URL${NC} (leave empty for local PostgreSQL): "
    read -r db_url
    if [ ! -z "$db_url" ]; then
        echo "DATABASE_URL=$db_url" >> .env
    else
        # Generate local PostgreSQL password
        db_pass=$(openssl rand -base64 32)
        echo "POSTGRES_PASSWORD=$db_pass" >> .env
        echo "DATABASE_URL=postgresql://postgres:$db_pass@homelab-postgres:5432/homelab" >> .env
        echo -e "${GREEN}‚úì Generated local PostgreSQL configuration${NC}"
    fi
    
    # Domain configuration
    echo -ne "${CYAN}Your domain${NC} (default: evindrake.net): "
    read -r domain
    domain=${domain:-evindrake.net}
    echo "DOMAIN=$domain" >> .env
    
    # Load the new environment
    set -a
    source .env
    set +a
    
    echo -e "\n${GREEN}‚úì Environment configuration complete!${NC}"
}

validate_env_vars() {
    local missing=()
    
    # Check critical variables
    [ -z "$OPENAI_API_KEY" ] && missing+=("OPENAI_API_KEY")
    [ -z "$DATABASE_URL" ] && [ -z "$POSTGRES_PASSWORD" ] && missing+=("DATABASE_URL or POSTGRES_PASSWORD")
    
    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${YELLOW}‚ö† Missing environment variables: ${missing[*]}${NC}"
        echo -n "Would you like to set them now? (y/n): "
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            interactive_env_setup
        fi
    else
        echo -e "${GREEN}‚úì All critical environment variables present${NC}"
    fi
}

# ============================================
# CLEANUP FUNCTIONS
# ============================================

cleanup_system() {
    echo "1. Stopping any existing containers..."
    docker compose down --remove-orphans 2>/dev/null || true
    
    echo "2. Removing dangling images..."
    local dangling=$(docker images -f "dangling=true" -q | wc -l)
    if [ "$dangling" -gt 0 ]; then
        docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null || true
        echo -e "${GREEN}‚úì Removed $dangling dangling images${NC}"
        ((ISSUES_FIXED++))
    fi
    
    echo "3. Cleaning unused volumes..."
    docker volume prune -f 2>/dev/null || true
    
    echo "4. Cleaning unused networks..."
    docker network prune -f 2>/dev/null || true
    
    echo "5. Removing old container logs..."
    find /var/lib/docker/containers -name "*.log" -size +100M -delete 2>/dev/null || true
    
    echo -e "${GREEN}‚úì System cleanup complete${NC}"
}

# ============================================
# DATABASE SETUP
# ============================================

setup_database() {
    echo "Setting up PostgreSQL database..."
    
    # Start PostgreSQL first
    docker compose up -d homelab-postgres 2>/dev/null || {
        echo -e "${YELLOW}‚ö† PostgreSQL start failed, attempting fix...${NC}"
        fix_postgresql
    }
    
    # Wait for PostgreSQL
    echo -n "Waiting for PostgreSQL to be ready"
    for i in {1..30}; do
        if docker exec homelab-postgres pg_isready -U postgres 2>/dev/null; then
            echo -e " ${GREEN}‚úì${NC}"
            break
        fi
        echo -n "."
        sleep 2
    done
    
    # Create required databases
    echo "Creating databases..."
    docker exec homelab-postgres psql -U postgres -c "CREATE DATABASE IF NOT EXISTS ticketbot;" 2>/dev/null || true
    docker exec homelab-postgres psql -U postgres -c "CREATE DATABASE IF NOT EXISTS streambot;" 2>/dev/null || true
    docker exec homelab-postgres psql -U postgres -c "CREATE DATABASE IF NOT EXISTS homelab_jarvis;" 2>/dev/null || true
    
    # Run migrations
    echo "Running database migrations..."
    fix_database_migrations
    
    echo -e "${GREEN}‚úì Database setup complete${NC}"
}

fix_postgresql() {
    echo "Fixing PostgreSQL setup..."
    
    # Ensure PostgreSQL user exists
    docker exec homelab-postgres psql -U postgres -c "
    DO \$\$
    BEGIN
        IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'postgres') THEN
            CREATE ROLE postgres WITH LOGIN SUPERUSER PASSWORD '${POSTGRES_PASSWORD:-defaultpass}';
        END IF;
    END
    \$\$;
    " 2>/dev/null || true
    
    ((ISSUES_FIXED++))
}

fix_database_migrations() {
    # Fix common migration issues
    echo "Checking for stuck migrations..."
    
    # Dashboard migrations
    if docker exec homelab-dashboard ls /app/migrations 2>/dev/null; then
        docker exec homelab-dashboard flask db upgrade 2>/dev/null || {
            echo "Fixing dashboard migrations..."
            docker exec homelab-dashboard flask db stamp head 2>/dev/null || true
            docker exec homelab-dashboard flask db migrate 2>/dev/null || true
            docker exec homelab-dashboard flask db upgrade 2>/dev/null || true
            ((ISSUES_FIXED++))
        }
    fi
    
    # Stream bot migrations
    if docker exec homelab-postgres psql -U postgres -d streambot -c "\dt" 2>/dev/null | grep -q "bot_instances"; then
        echo -e "${GREEN}‚úì Stream bot tables exist${NC}"
    else
        echo "Creating stream bot tables..."
        docker exec homelab-postgres psql -U postgres -d streambot -c "
        CREATE TABLE IF NOT EXISTS bot_instances (
            id SERIAL PRIMARY KEY,
            user_id VARCHAR(255),
            platform VARCHAR(50),
            created_at TIMESTAMP DEFAULT NOW()
        );" 2>/dev/null || true
        ((ISSUES_FIXED++))
    fi
}

# ============================================
# DEPLOYMENT
# ============================================

deploy_all_services() {
    echo "Building all services..."
    docker compose build --parallel
    
    echo -e "\nStarting services in dependency order..."
    
    # Core infrastructure (must be first)
    echo "1. Core infrastructure..."
    docker compose up -d homelab-postgres homelab-redis homelab-minio
    sleep 5
    
    # Application tier
    echo "2. Application services..."
    docker compose up -d homelab-dashboard homelab-celery-worker
    sleep 3
    
    # Bot services
    echo "3. Bot services..."
    docker compose up -d discord-bot stream-bot
    sleep 2
    
    # Web services
    echo "4. Web services..."
    docker compose up -d rig-city-site scarletredjoker-web
    
    # Additional services
    echo "5. Additional services..."
    docker compose up -d plex-server n8n homeassistant vnc-desktop code-server
    
    # Reverse proxy (must be last)
    echo "6. Reverse proxy..."
    docker compose up -d caddy
    
    echo -e "${GREEN}‚úì All services deployed${NC}"
}

# ============================================
# HEALTH CHECKS & AUTO-FIX
# ============================================

perform_health_checks() {
    echo "Performing health checks on all services..."
    
    local all_services=(
        "homelab-postgres"
        "homelab-redis"
        "homelab-minio"
        "homelab-dashboard"
        "homelab-celery-worker"
        "discord-bot"
        "stream-bot"
        "caddy"
        "vnc-desktop"
        "code-server"
        "plex-server"
        "n8n"
        "homeassistant"
        "rig-city-site"
        "scarletredjoker-web"
    )
    
    SERVICES_RUNNING=0
    local failed_services=()
    
    for service in "${all_services[@]}"; do
        if docker ps --format "{{.Names}}" | grep -q "^${service}$"; then
            local status=$(docker inspect --format='{{.State.Running}}' $service 2>/dev/null)
            if [ "$status" = "true" ]; then
                echo -e "  $service: ${GREEN}‚úì Running${NC}"
                ((SERVICES_RUNNING++))
            else
                echo -e "  $service: ${RED}‚úó Not Running${NC}"
                failed_services+=($service)
                ((ISSUES_FOUND++))
            fi
        else
            echo -e "  $service: ${RED}‚úó Not Found${NC}"
            failed_services+=($service)
            ((ISSUES_FOUND++))
        fi
    done
    
    echo -e "\n${BOLD}Status: $SERVICES_RUNNING/$SERVICES_EXPECTED services running${NC}"
    
    # Specific service tests
    test_jarvis_ai
    test_database_connectivity
    
    return ${#failed_services[@]}
}

test_jarvis_ai() {
    echo -n "Testing Jarvis AI: "
    if docker exec homelab-dashboard python -c "
import os, requests
api_key = os.environ.get('OPENAI_API_KEY', '')
if api_key:
    resp = requests.post('https://api.openai.com/v1/chat/completions',
        headers={'Authorization': f'Bearer {api_key}', 'Content-Type': 'application/json'},
        json={'model': 'gpt-3.5-turbo', 'messages': [{'role': 'user', 'content': 'test'}], 'max_tokens': 5},
        timeout=5)
    exit(0 if resp.status_code == 200 else 1)
else:
    exit(1)
" 2>/dev/null; then
        echo -e "${GREEN}‚úì Working${NC}"
    else
        echo -e "${RED}‚úó Failed${NC}"
        ((ISSUES_FOUND++))
        # Auto-fix
        echo "  Fixing Jarvis AI model..."
        docker exec homelab-dashboard sed -i "s/'gpt-5'/'gpt-3.5-turbo'/g" /app/services/ai_service.py 2>/dev/null || true
        docker exec homelab-dashboard sed -i "s/'gpt-5'/'gpt-3.5-turbo'/g" /app/routes/ai_chat_api.py 2>/dev/null || true
        docker compose restart homelab-dashboard
        ((ISSUES_FIXED++))
    fi
}

test_database_connectivity() {
    echo -n "Testing database connectivity: "
    if docker exec homelab-postgres psql -U postgres -c "SELECT 1" >/dev/null 2>&1; then
        echo -e "${GREEN}‚úì Connected${NC}"
    else
        echo -e "${RED}‚úó Failed${NC}"
        ((ISSUES_FOUND++))
    fi
}

auto_fix_issues() {
    if [ $ISSUES_FOUND -gt 0 ]; then
        echo -e "\n${YELLOW}Found $ISSUES_FOUND issues. Attempting auto-fix...${NC}"
        
        # Restart failed services
        echo "Restarting failed services..."
        for service in $(docker compose ps --services); do
            if ! docker ps --format "{{.Names}}" | grep -q "^${service}$"; then
                echo "  Starting $service..."
                docker compose up -d $service
                ((ISSUES_FIXED++))
            fi
        done
        
        # Fix VNC password if needed
        if ! docker exec vnc-desktop test -f /home/ubuntu/.vnc/passwd 2>/dev/null; then
            echo "Fixing VNC password..."
            docker exec vnc-desktop bash -c "echo 'password' | vncpasswd -f > /home/ubuntu/.vnc/passwd" 2>/dev/null || true
            docker compose restart vnc-desktop
            ((ISSUES_FIXED++))
        fi
        
        # Fix permissions
        echo "Fixing Docker permissions..."
        sudo chmod 666 /var/run/docker.sock 2>/dev/null || true
        
        sleep 10
    fi
}

final_verification() {
    echo "Running final verification..."
    
    # Count running services again
    SERVICES_RUNNING=0
    for service in $(docker compose ps --services); do
        if docker ps --format "{{.Names}}" | grep -q "^${service}$"; then
            ((SERVICES_RUNNING++))
        fi
    done
    
    # Check for remaining issues
    local dangling=$(docker images -f "dangling=true" -q | wc -l)
    if [ "$dangling" -gt 0 ]; then
        echo -e "${YELLOW}‚ö† Found $dangling dangling images${NC}"
        ((ISSUES_FOUND++))
    fi
    
    # Database check
    if ! docker exec homelab-postgres pg_isready -U postgres 2>/dev/null; then
        echo -e "${YELLOW}‚ö† Database not available${NC}"
        ((ISSUES_FOUND++))
    fi
    
    if [ $SERVICES_RUNNING -eq $SERVICES_EXPECTED ]; then
        echo -e "${GREEN}‚úì All $SERVICES_EXPECTED services running successfully!${NC}"
    else
        echo -e "${YELLOW}‚ö† Only $SERVICES_RUNNING/$SERVICES_EXPECTED services running${NC}"
    fi
}

show_summary() {
    echo -e "\n${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë                     DEPLOYMENT SUMMARY                        ‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    
    if [ $SERVICES_RUNNING -eq $SERVICES_EXPECTED ] && [ $ISSUES_FOUND -eq $ISSUES_FIXED ]; then
        echo -e "  Status: ${GREEN}‚úÖ FULLY OPERATIONAL${NC}"
    elif [ $SERVICES_RUNNING -ge $((SERVICES_EXPECTED - 1)) ]; then
        echo -e "  Status: ${YELLOW}‚ö† Most services running (check logs for issues)${NC}"
    else
        echo -e "  Status: ${RED}‚ùå Issues detected - manual intervention may be needed${NC}"
    fi
    
    echo ""
    echo "  Services: $SERVICES_RUNNING/$SERVICES_EXPECTED running"
    echo "  Issues Found: $ISSUES_FOUND"
    echo "  Issues Fixed: $ISSUES_FIXED"
    
    if [ $((ISSUES_FOUND - ISSUES_FIXED)) -gt 0 ]; then
        echo -e "  ${YELLOW}‚ö† $(($ISSUES_FOUND - $ISSUES_FIXED)) issues could not be auto-fixed${NC}"
    fi
    
    echo ""
    echo -e "${BOLD}Service URLs:${NC}"
    echo "  üåê Dashboard: https://host.evindrake.net"
    echo "  ü§ñ Discord Bot: https://bot.rig-city.com"
    echo "  üì∫ Stream Bot: https://stream.rig-city.com"
    echo "  üñ•Ô∏è VNC Desktop: https://vnc.evindrake.net"
    echo "  üíª Code Server: https://code.evindrake.net"
    echo "  üé¨ Plex: https://plex.evindrake.net"
    echo "  üîÑ N8N: https://n8n.evindrake.net"
    echo "  üè† Home Assistant: https://home.evindrake.net"
    echo ""
    
    if [ $ISSUES_FOUND -gt $ISSUES_FIXED ]; then
        echo -e "${YELLOW}Run './homelab logs' to check service logs for remaining issues.${NC}"
    fi
}

# ============================================
# QUICK COMMANDS
# ============================================

quick_deploy() {
    echo -e "${CYAN}Quick Deployment (using cache)${NC}"
    docker compose up -d --build
    perform_health_checks
}

quick_stop() {
    echo -e "${CYAN}Stopping all services...${NC}"
    docker compose down
    echo -e "${GREEN}‚úì All services stopped${NC}"
}

quick_restart() {
    echo -e "${CYAN}Restarting all services...${NC}"
    docker compose restart
    echo -e "${GREEN}‚úì All services restarted${NC}"
}

view_logs() {
    local service=${1:-all}
    if [ "$service" = "all" ]; then
        docker compose logs -f --tail=100
    else
        docker compose logs -f --tail=100 $service
    fi
}

show_status() {
    docker compose ps --format "table {{.Service}}\t{{.Status}}\t{{.State}}"
}

# ============================================
# INTERACTIVE MENU
# ============================================

interactive_menu() {
    while true; do
        clear
        echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
        echo -e "${CYAN}‚ïë           HOMELAB UNIFIED PLATFORM v3.0                       ‚ïë${NC}"
        echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
        echo ""
        
        # Quick status check
        local running=$(docker ps --format "{{.Names}}" | wc -l)
        if [ $running -eq $SERVICES_EXPECTED ]; then
            echo -e "  Status: ${GREEN}‚úÖ All services running${NC}"
        else
            echo -e "  Status: ${YELLOW}‚ö† $running/$SERVICES_EXPECTED services running${NC}"
        fi
        echo ""
        
        echo "${BOLD}Options:${NC}"
        echo ""
        echo "  ${GREEN}[1]${NC} üöÄ Full Startup (Setup + Deploy + Fix)"
        echo "  ${GREEN}[2]${NC} ‚ö° Quick Deploy (cached)"
        echo "  ${GREEN}[3]${NC} üîÑ Restart All Services"
        echo "  ${GREEN}[4]${NC} üõë Stop All Services"
        echo "  ${GREEN}[5]${NC} üìä Show Status"
        echo "  ${GREEN}[6]${NC} üìã View Logs"
        echo "  ${GREEN}[7]${NC} üîß Fix Issues"
        echo "  ${GREEN}[8]${NC} üßπ Clean System"
        echo "  ${GREEN}[9]${NC} ‚öôÔ∏è  Configure Environment"
        echo "  ${GREEN}[0]${NC} üö™ Exit"
        echo ""
        echo -n "Select option: "
        read -r choice
        
        case $choice in
            1) auto_startup ;;
            2) quick_deploy ;;
            3) quick_restart ;;
            4) quick_stop ;;
            5) show_status; read -p "Press Enter to continue..." ;;
            6) 
                echo -n "Service name (or 'all'): "
                read -r service
                view_logs $service
                ;;
            7) 
                cleanup_system
                auto_fix_issues
                perform_health_checks
                ;;
            8) cleanup_system ;;
            9) interactive_env_setup ;;
            0) exit 0 ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1 ;;
        esac
        
        if [ "$choice" != "6" ]; then
            echo ""
            read -p "Press Enter to continue..."
        fi
    done
}

# ============================================
# MAIN EXECUTION
# ============================================

main() {
    # Check Docker
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}‚ùå Docker is not installed!${NC}"
        echo "Install Docker first: https://docs.docker.com/get-docker/"
        exit 1
    fi
    
    # Parse arguments
    case "${1:-}" in
        start|up|deploy)
            auto_startup
            ;;
        stop|down)
            quick_stop
            ;;
        restart)
            quick_restart
            ;;
        status|ps)
            show_status
            ;;
        logs|log)
            view_logs "${2:-all}"
            ;;
        fix)
            cleanup_system
            auto_fix_issues
            perform_health_checks
            ;;
        clean)
            cleanup_system
            ;;
        setup)
            interactive_env_setup
            ;;
        help|--help|-h)
            echo "Usage: $0 [command]"
            echo ""
            echo "Commands:"
            echo "  start    - Full startup with fixes"
            echo "  stop     - Stop all services"
            echo "  restart  - Restart all services"
            echo "  status   - Show service status"
            echo "  logs     - View logs"
            echo "  fix      - Fix issues"
            echo "  clean    - Clean system"
            echo "  setup    - Configure environment"
            echo ""
            echo "Or run without arguments for interactive mode"
            ;;
        "")
            interactive_menu
            ;;
        *)
            echo -e "${RED}Unknown command: $1${NC}"
            echo "Run '$0 help' for usage"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"