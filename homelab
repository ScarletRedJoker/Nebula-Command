#!/bin/bash
# ╔════════════════════════════════════════════════════════════════╗
# ║              HOMELAB - PRODUCTION-READY MANAGEMENT            ║
# ╚════════════════════════════════════════════════════════════════╝

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# Auto-detect project root
if [ -d "/home/evin/contain/HomeLabHub" ]; then
    # On Ubuntu server
    PROJECT_ROOT="/home/evin/contain/HomeLabHub"
else
    # In development/Replit
    PROJECT_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
fi

# Phase 2: Detect DEPLOYMENT_PATH for per-environment configs
# Priority: ENV var > auto-detect > fallback to root .env
# Use ${DEPLOYMENT_PATH:-} to avoid unbound variable error with set -u
if [ -z "${DEPLOYMENT_PATH:-}" ]; then
    # Auto-detect if not set
    if [ -d "$PROJECT_ROOT/deployment/prod/evindrake_net" ] && [ -f "$PROJECT_ROOT/deployment/prod/evindrake_net/.env" ]; then
        # Auto-detect production deployment on evindrake.net host
        DEPLOYMENT_PATH="$PROJECT_ROOT/deployment/prod/evindrake_net"
    elif [ -d "$PROJECT_ROOT/deployment/dev/localhost" ] && [ -f "$PROJECT_ROOT/deployment/dev/localhost/.env" ]; then
        # Auto-detect development deployment
        DEPLOYMENT_PATH="$PROJECT_ROOT/deployment/dev/localhost"
    else
        # Fallback: Use root directory (legacy behavior)
        DEPLOYMENT_PATH="$PROJECT_ROOT"
    fi
fi

# CRITICAL: Export before docker compose calls
export DEPLOYMENT_PATH

ENV_FILE="${DEPLOYMENT_PATH}/.env"
COMPOSE_FILE="$PROJECT_ROOT/docker-compose.yml"

echo -e "${CYAN}Project Root: $PROJECT_ROOT${NC}"
echo -e "${CYAN}Deployment Path: $DEPLOYMENT_PATH${NC}"

# Verify files exist
if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}ERROR: .env file not found at $ENV_FILE${NC}"
    echo ""
    echo "Phase 1 deployment configs not generated!"
    echo "Run: python3 config/scripts/generate-config.py prod evindrake_net"
    echo ""
    exit 1
fi

if [ ! -f "$COMPOSE_FILE" ]; then
    echo -e "${RED}ERROR: docker-compose.yml not found at $COMPOSE_FILE${NC}"
    exit 1
fi

# Docker Compose command with ABSOLUTE PATHS
# Phase 2: Use modular bundles when available, fallback to monolith
compose() {
    if [ -f "$PROJECT_ROOT/orchestration/compose.all.yml" ]; then
        # Modular approach - use compose.all.yml which includes all bundles
        # CRITICAL: --env-file ensures ${DEPLOYMENT_PATH} is substituted in compose files
        docker compose \
            --project-directory "$PROJECT_ROOT" \
            --env-file "$ENV_FILE" \
            -f "$PROJECT_ROOT/orchestration/compose.all.yml" \
            "$@"
    else
        # Legacy fallback - use monolithic docker-compose.yml
        docker compose \
            --project-directory "$PROJECT_ROOT" \
            --env-file "$ENV_FILE" \
            -f "$COMPOSE_FILE" \
            "$@"
    fi
}

# Service list
ALL_SERVICES=(
    "homelab-postgres" "homelab-redis" "homelab-minio"
    "homelab-dashboard" "homelab-celery-worker"
    "discord-bot" "stream-bot"
    "caddy" "vnc-desktop" "code-server"
    "plex-server" "n8n" "homeassistant"
    "rig-city-site" "scarletredjoker-web"
)

# Check if service is running
is_running() {
    docker ps --format "{{.Names}}" | grep -q "^$1$"
}

# Count running services
count_running() {
    local count=0
    for service in "${ALL_SERVICES[@]}"; do
        is_running "$service" && ((count++))
    done
    echo $count
}

# ============================================
# FIX COMMAND - Simple and Effective
# ============================================
fix() {
    echo -e "${CYAN}═══ FIXING HOMELAB ═══${NC}\n"
    
    echo "Project: $PROJECT_ROOT"
    echo "Env File: $ENV_FILE"
    echo ""
    
    # Rebuild bots with --no-cache to pick up password changes
    echo -e "${CYAN}[1/4] Rebuilding bots without cache (ensures password changes are applied)...${NC}"
    compose build --no-cache discord-bot stream-bot
    
    # Force recreate ALL containers with correct environment
    echo -e "${CYAN}[2/4] Force recreating all services with environment...${NC}"
    compose up -d --force-recreate
    
    echo -e "${CYAN}[3/4] Waiting for stability...${NC}"
    sleep 10
    
    # Create databases if PostgreSQL is ready
    echo -e "${CYAN}[4/4] Setting up databases...${NC}"
    if docker exec homelab-postgres pg_isready -U postgres &>/dev/null; then
        for db in ticketbot streambot homelab_jarvis; do
            if ! docker exec homelab-postgres psql -U postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw "$db"; then
                echo "  Creating database: $db"
                docker exec homelab-postgres psql -U postgres -c "CREATE DATABASE $db;" 2>/dev/null || true
            fi
        done
        echo -e "${GREEN}✓ Databases ready${NC}"
    fi
    
    # Status
    local running=$(count_running)
    echo ""
    if [ $running -eq 15 ]; then
        echo -e "${GREEN}✅ SUCCESS! All 15/15 services running!${NC}"
    else
        echo -e "${YELLOW}⚠ $running/15 services running${NC}"
        echo "Check logs: ./homelab logs"
    fi
}

# ============================================
# STATUS COMMAND
# ============================================
status() {
    echo -e "\n${CYAN}═══ Service Status ═══${NC}\n"
    
    # Phase 2: Use modular bundles when available
    if [ -f "$PROJECT_ROOT/orchestration/services.yaml" ]; then
        # Use modular approach with compose ps
        compose ps
        echo ""
    else
        # Legacy fallback - manual status check
        local running=0
        for service in "${ALL_SERVICES[@]}"; do
            if is_running "$service"; then
                echo -e "$service: ${GREEN}● Running${NC}"
                ((running++))
            else
                echo -e "$service: ${RED}○ Stopped${NC}"
            fi
        done
        
        echo ""
        if [ $running -eq 15 ]; then
            echo -e "${GREEN}✅ All 15/15 services running${NC}"
        else
            echo -e "${YELLOW}⚠ $running/15 services running${NC}"
        fi
    fi
}

# ============================================
# LOGS COMMAND with Auto-Save
# ============================================
logs() {
    mkdir -p "$PROJECT_ROOT/logs"
    local timestamp=$(date +%Y%m%d-%H%M%S)
    
    # Phase 2: Works with both modular and monolithic compose
    if [ $# -eq 0 ]; then
        # All services
        echo -e "${CYAN}Showing logs for all services...${NC}"
        compose logs --tail=100 -f | tee "$PROJECT_ROOT/logs/all-services-$timestamp.log"
    else
        # Specific service
        echo -e "${CYAN}Showing logs for $1...${NC}"
        compose logs --tail=100 -f "$1" | tee "$PROJECT_ROOT/logs/$1-$timestamp.log"
    fi
}

# ============================================
# DEBUG COMMAND - Show What Docker Sees
# ============================================
debug() {
    echo -e "${CYAN}═══ Debug Information ═══${NC}\n"
    
    echo "Project Root: $PROJECT_ROOT"
    echo "Current Dir: $(pwd)"
    echo ""
    
    echo -e "${CYAN}Checking .env file:${NC}"
    if [ -f "$ENV_FILE" ]; then
        echo -e "${GREEN}✓ .env exists${NC}"
        echo "  Variables loaded:"
        grep -c "=" "$ENV_FILE" | xargs echo "  "
        echo ""
        echo "  Checking critical variables:"
        grep "^WEB_USERNAME=" "$ENV_FILE" || echo -e "  ${RED}✗ WEB_USERNAME missing${NC}"
        grep "^WEB_PASSWORD=" "$ENV_FILE" || echo -e "  ${RED}✗ WEB_PASSWORD missing${NC}"
        grep "^POSTGRES_PASSWORD=" "$ENV_FILE" || echo -e "  ${RED}✗ POSTGRES_PASSWORD missing${NC}"
    else
        echo -e "${RED}✗ .env NOT FOUND${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}Checking homelab-dashboard container environment:${NC}"
    if is_running "homelab-dashboard"; then
        echo "  WEB_USERNAME in container:"
        docker exec homelab-dashboard env | grep "WEB_USERNAME" || echo -e "  ${RED}✗ NOT SET${NC}"
        echo "  POSTGRES_PASSWORD in container:"
        docker exec homelab-dashboard env | grep "POSTGRES_PASSWORD" || echo -e "  ${RED}✗ NOT SET${NC}"
    else
        echo -e "${YELLOW}  Dashboard not running${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}Service Status:${NC}"
    status
}

# ============================================
# HEALTH COMMAND - Comprehensive Health Checks
# ============================================
health() {
    echo -e "\n${CYAN}═══ Comprehensive Health Check ═══${NC}\n"
    
    local health_issues=0
    
    # 1. Database Connectivity
    echo -e "${CYAN}[1/5] Database Connections${NC}"
    if is_running "homelab-postgres"; then
        if docker exec homelab-postgres pg_isready -U postgres &>/dev/null; then
            echo -e "  ${GREEN}✓${NC} PostgreSQL responding"
            
            # Check each database
            for db in ticketbot streambot homelab_jarvis; do
                if docker exec homelab-postgres psql -U postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw "$db"; then
                    echo -e "  ${GREEN}✓${NC} Database: $db"
                else
                    echo -e "  ${RED}✗${NC} Database missing: $db"
                    ((health_issues++))
                fi
            done
        else
            echo -e "  ${RED}✗${NC} PostgreSQL not responding"
            ((health_issues++))
        fi
    else
        echo -e "  ${RED}✗${NC} PostgreSQL container not running"
        ((health_issues++))
    fi
    
    # 2. API Endpoint Tests
    echo -e "\n${CYAN}[2/5] API Endpoints${NC}"
    test_endpoint() {
        local name=$1
        local url=$2
        local expected_codes=$3
        
        local status=$(curl -s -o /dev/null -w "%{http_code}" "$url" 2>/dev/null || echo "000")
        if echo "$expected_codes" | grep -q "$status"; then
            echo -e "  ${GREEN}✓${NC} $name (HTTP $status)"
        else
            echo -e "  ${RED}✗${NC} $name (HTTP $status, expected: $expected_codes)"
            ((health_issues++))
        fi
    }
    
    test_endpoint "Dashboard" "http://localhost:8080/" "200 302"
    test_endpoint "Discord Bot" "http://localhost:4000/health" "200 302 404"
    test_endpoint "Stream Bot" "http://localhost:5000/health" "200 302 404"
    test_endpoint "MinIO" "http://localhost:9000/minio/health/live" "200"
    
    # 3. Disk Space
    echo -e "\n${CYAN}[3/5] Disk Space${NC}"
    local disk_usage=$(df -h "$PROJECT_ROOT" | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ "$disk_usage" -lt 80 ]; then
        echo -e "  ${GREEN}✓${NC} Disk usage: ${disk_usage}%"
    elif [ "$disk_usage" -lt 90 ]; then
        echo -e "  ${YELLOW}⚠${NC} Disk usage: ${disk_usage}% (warning)"
        ((health_issues++))
    else
        echo -e "  ${RED}✗${NC} Disk usage: ${disk_usage}% (critical)"
        ((health_issues++))
    fi
    
    # 4. Memory Usage
    echo -e "\n${CYAN}[4/5] Memory Usage${NC}"
    local mem_available=$(free -m | awk 'NR==2 {print $7}')
    local mem_total=$(free -m | awk 'NR==2 {print $2}')
    local mem_percent=$((100 - (mem_available * 100 / mem_total)))
    
    if [ "$mem_percent" -lt 80 ]; then
        echo -e "  ${GREEN}✓${NC} Memory usage: ${mem_percent}%"
    elif [ "$mem_percent" -lt 90 ]; then
        echo -e "  ${YELLOW}⚠${NC} Memory usage: ${mem_percent}% (warning)"
    else
        echo -e "  ${RED}✗${NC} Memory usage: ${mem_percent}% (critical)"
        ((health_issues++))
    fi
    
    # 5. Container Health Status
    echo -e "\n${CYAN}[5/5] Container Health Status${NC}"
    for service in "${ALL_SERVICES[@]}"; do
        if is_running "$service"; then
            local health_status=$(docker inspect "$service" --format='{{.State.Health.Status}}' 2>/dev/null || echo "no-healthcheck")
            if [ "$health_status" = "healthy" ] || [ "$health_status" = "no-healthcheck" ]; then
                echo -e "  ${GREEN}✓${NC} $service"
            elif [ "$health_status" = "starting" ]; then
                echo -e "  ${YELLOW}⟳${NC} $service (starting)"
            else
                echo -e "  ${RED}✗${NC} $service ($health_status)"
                ((health_issues++))
            fi
        else
            echo -e "  ${RED}○${NC} $service (not running)"
            ((health_issues++))
        fi
    done
    
    # Summary
    echo ""
    if [ $health_issues -eq 0 ]; then
        echo -e "${GREEN}✅ All health checks passed!${NC}"
        return 0
    else
        echo -e "${RED}⚠ Found $health_issues health issue(s)${NC}"
        echo "Run './homelab fix' to attempt automatic repair"
        return 1
    fi
}

# ============================================
# VALIDATE-ENV COMMAND - Environment Validation
# ============================================
validate_env() {
    echo -e "\n${CYAN}═══ Environment Validation ═══${NC}\n"
    
    if [ ! -f "$ENV_FILE" ]; then
        echo -e "${RED}✗ .env file not found at $ENV_FILE${NC}"
        echo "Create it from template: cp .env.example .env"
        return 1
    fi
    
    echo "Checking required variables..."
    echo ""
    
    local required_vars=(
        "POSTGRES_PASSWORD"
        "DISCORD_DB_PASSWORD"
        "STREAMBOT_DB_PASSWORD"
        "JARVIS_DB_PASSWORD"
        "WEB_USERNAME"
        "WEB_PASSWORD"
        "SESSION_SECRET"
        "DISCORD_BOT_TOKEN"
        "DISCORD_CLIENT_ID"
        "DISCORD_CLIENT_SECRET"
        "OPENAI_API_KEY"
    )
    
    local missing_vars=()
    local present_vars=()
    
    for var in "${required_vars[@]}"; do
        if grep -q "^${var}=" "$ENV_FILE" && [ -n "$(grep "^${var}=" "$ENV_FILE" | cut -d'=' -f2)" ]; then
            echo -e "  ${GREEN}✓${NC} $var"
            present_vars+=("$var")
        else
            echo -e "  ${RED}✗${NC} $var - MISSING or EMPTY"
            missing_vars+=("$var")
        fi
    done
    
    echo ""
    echo "Summary: ${#present_vars[@]}/${#required_vars[@]} required variables present"
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        echo ""
        echo -e "${RED}Missing variables:${NC}"
        for var in "${missing_vars[@]}"; do
            echo "  - $var"
        done
        echo ""
        echo "Update your .env file before deployment"
        return 1
    else
        echo -e "\n${GREEN}✅ All required variables present${NC}"
        return 0
    fi
}

# ============================================
# BACKUP COMMAND - Database Backups
# ============================================
backup() {
    echo -e "\n${CYAN}═══ Database Backup ═══${NC}\n"
    
    if ! is_running "homelab-postgres"; then
        echo -e "${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    # Create backups directory with secure permissions
    local backup_dir="$PROJECT_ROOT/backups"
    mkdir -p "$backup_dir"
    chmod 700 "$backup_dir"
    
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_file="$backup_dir/homelab-backup-$timestamp.sql"
    
    echo "Backing up all databases to:"
    echo "  $backup_file"
    echo ""
    
    # Extract PostgreSQL password from .env (secure method)
    local POSTGRES_PASSWORD=$(grep "^POSTGRES_PASSWORD=" "$ENV_FILE" | cut -d'=' -f2-)
    
    if [ -z "$POSTGRES_PASSWORD" ]; then
        echo -e "${RED}✗ POSTGRES_PASSWORD not found in .env${NC}"
        return 1
    fi
    
    # Backup all databases using PGPASSWORD (no credentials in process list)
    if PGPASSWORD="$POSTGRES_PASSWORD" docker exec homelab-postgres \
        pg_dumpall -U postgres > "$backup_file"; then
        
        # Set secure permissions on backup file (owner read/write only)
        chmod 600 "$backup_file"
        
        local size=$(du -h "$backup_file" | cut -f1)
        echo -e "${GREEN}✅ Backup created successfully${NC}"
        echo "  Size: $size"
        echo "  File: $(basename $backup_file)"
        echo "  Permissions: 600 (secure)"
        echo ""
        echo "To restore: ./homelab restore $backup_file"
        
        # Keep only last 10 backups
        cd "$backup_dir"
        ls -t homelab-backup-*.sql 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null
        local backup_count=$(ls -1 homelab-backup-*.sql 2>/dev/null | wc -l)
        echo "  Backups retained: $backup_count"
        
        # Clear password from environment
        unset POSTGRES_PASSWORD
        return 0
    else
        echo -e "${RED}✗ Backup failed${NC}"
        rm -f "$backup_file"
        unset POSTGRES_PASSWORD
        return 1
    fi
}

# ============================================
# RESTORE COMMAND - Database Restore
# ============================================
restore() {
    local input_file="$1"
    
    # Whitelist: Only allow backups from secure directory
    local BACKUPS_DIR="$PROJECT_ROOT/backups"
    
    if [ -z "$input_file" ]; then
        echo -e "${RED}✗ Usage: ./homelab restore <backup-file>${NC}"
        echo ""
        echo "Available backups:"
        if [ -d "$BACKUPS_DIR" ]; then
            ls -1t "$BACKUPS_DIR/"homelab-backup-*.sql 2>/dev/null | head -5 | while read f; do
                echo "  $(basename $f) ($(du -h "$f" | cut -f1))"
            done
        else
            echo "  No backups found in $BACKUPS_DIR"
        fi
        return 1
    fi
    
    # Convert to absolute path for validation
    local backup_file
    if [[ "$input_file" = /* ]]; then
        backup_file="$input_file"
    else
        backup_file="$(cd "$(dirname "$input_file")" 2>/dev/null && pwd)/$(basename "$input_file")"
    fi
    
    # SECURITY: Validate file path is in whitelisted directory (no traversal)
    if [[ "$backup_file" != "$BACKUPS_DIR"/* ]]; then
        echo -e "${RED}✗ SECURITY: Backup file must be in $BACKUPS_DIR${NC}"
        echo "  Provided: $backup_file"
        echo "  Required: $BACKUPS_DIR/"
        return 1
    fi
    
    # SECURITY: Verify file exists and is a regular file (not symlink, device, etc.)
    if [ ! -f "$backup_file" ] || [ ! -r "$backup_file" ]; then
        echo -e "${RED}✗ Backup file not found or not readable: $backup_file${NC}"
        return 1
    fi
    
    # Detect if file is a symbolic link (additional security)
    if [ -L "$backup_file" ]; then
        echo -e "${RED}✗ SECURITY: Symbolic links are not allowed${NC}"
        return 1
    fi
    
    # SECURITY: Check file size constraints (min 1KB, max 10GB)
    local size
    # Use stat (works on both macOS and Linux)
    size=$(stat -f%z "$backup_file" 2>/dev/null || stat -c%s "$backup_file" 2>/dev/null)
    
    if [ -z "$size" ]; then
        echo -e "${RED}✗ Could not determine file size${NC}"
        return 1
    fi
    
    local min_size=1024          # 1KB minimum
    local max_size=10737418240   # 10GB maximum
    
    if [ "$size" -lt "$min_size" ]; then
        echo -e "${RED}✗ Backup file too small (${size} bytes, minimum ${min_size} bytes)${NC}"
        echo "  File may be corrupted or empty"
        return 1
    fi
    
    if [ "$size" -gt "$max_size" ]; then
        echo -e "${RED}✗ Backup file too large (${size} bytes, maximum ${max_size} bytes)${NC}"
        echo "  File may be corrupted or malicious"
        return 1
    fi
    
    # Show details and get confirmation
    echo -e "\n${CYAN}═══ Database Restore ═══${NC}\n"
    echo -e "${YELLOW}⚠ WARNING: This will REPLACE all current databases!${NC}"
    echo ""
    echo "Backup file: $(basename $backup_file)"
    echo "Location: $backup_file"
    echo "Size: $(du -h "$backup_file" | cut -f1) ($(numfmt --to=iec-i --suffix=B $size 2>/dev/null || echo "${size} bytes"))"
    echo "Modified: $(stat -f%Sm "$backup_file" 2>/dev/null || stat -c%y "$backup_file" 2>/dev/null)"
    echo ""
    echo "Services that will be stopped:"
    echo "  - homelab-dashboard"
    echo "  - homelab-celery-worker"
    echo "  - discord-bot"
    echo "  - stream-bot"
    echo ""
    read -p "Type 'yes' to continue: " confirm
    
    if [ "$confirm" != "yes" ]; then
        echo "Restore cancelled"
        return 0
    fi
    
    if ! is_running "homelab-postgres"; then
        echo -e "\n${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    # Stop all services that use the database
    echo -e "\n${CYAN}Stopping dependent services...${NC}"
    compose stop homelab-dashboard homelab-celery-worker discord-bot stream-bot
    sleep 3
    
    # Extract PostgreSQL password from .env (secure method)
    local POSTGRES_PASSWORD=$(grep "^POSTGRES_PASSWORD=" "$ENV_FILE" | cut -d'=' -f2-)
    
    if [ -z "$POSTGRES_PASSWORD" ]; then
        echo -e "${RED}✗ POSTGRES_PASSWORD not found in .env${NC}"
        echo "Restarting services..."
        compose start homelab-dashboard homelab-celery-worker discord-bot stream-bot
        return 1
    fi
    
    # Restore with PGPASSWORD (no credentials in process list)
    echo -e "${CYAN}Restoring databases from backup...${NC}"
    if PGPASSWORD="$POSTGRES_PASSWORD" docker exec -i homelab-postgres \
        psql -U postgres < "$backup_file"; then
        
        # Clear password from environment
        unset POSTGRES_PASSWORD
        
        echo -e "\n${GREEN}✅ Restore completed successfully${NC}"
        echo ""
        echo -e "${CYAN}Restarting services...${NC}"
        compose start homelab-dashboard homelab-celery-worker discord-bot stream-bot
        sleep 5
        
        echo ""
        echo -e "${GREEN}✅ All services restarted${NC}"
        echo "Run './homelab status' to verify services"
        return 0
    else
        # Clear password from environment
        unset POSTGRES_PASSWORD
        
        echo -e "\n${RED}✗ Restore failed${NC}"
        echo -e "${YELLOW}⚠ Services have been stopped for safety${NC}"
        echo ""
        echo "Manual recovery steps:"
        echo "  1. Check logs: docker logs homelab-postgres"
        echo "  2. Verify backup file integrity"
        echo "  3. Restore from another backup"
        echo "  4. Or restart services: ./homelab start"
        return 1
    fi
}

# ============================================
# UPDATE COMMAND - Git Pull and Redeploy
# ============================================
update() {
    echo -e "\n${CYAN}═══ Update Deployment ═══${NC}\n"
    
    cd "$PROJECT_ROOT"
    
    # Check if git repo
    if [ ! -d ".git" ]; then
        echo -e "${RED}✗ Not a git repository${NC}"
        return 1
    fi
    
    # Create backup before update
    echo "Creating pre-update backup..."
    backup
    
    # Fetch updates
    echo ""
    echo "Fetching latest changes..."
    git fetch origin
    
    # Show what would change
    local changes=$(git rev-list HEAD..origin/main --count 2>/dev/null || echo "0")
    
    if [ "$changes" = "0" ]; then
        echo -e "${GREEN}✓ Already up to date${NC}"
        return 0
    fi
    
    echo ""
    echo -e "${YELLOW}$changes commit(s) to pull${NC}"
    git log --oneline HEAD..origin/main | head -5
    echo ""
    read -p "Continue with update? (y/N): " confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Update cancelled"
        return 0
    fi
    
    # Pull changes
    echo ""
    echo "Pulling changes..."
    git pull origin main
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}✗ Git pull failed${NC}"
        echo "Resolve conflicts manually, then run './homelab fix'"
        return 1
    fi
    
    # Rebuild and restart
    echo ""
    echo "Rebuilding and redeploying..."
    compose build
    compose up -d --force-recreate
    
    echo ""
    echo -e "${GREEN}✅ Update completed${NC}"
    echo "Run './homelab health' to verify deployment"
}

# ============================================
# REBUILD COMMAND - Rebuild Specific Service
# ============================================
rebuild() {
    local service="$1"
    
    if [ -z "$service" ]; then
        echo -e "${RED}✗ Usage: ./homelab rebuild <service>${NC}"
        echo ""
        echo "Available services:"
        for svc in "${ALL_SERVICES[@]}"; do
            echo "  - $svc"
        done
        return 1
    fi
    
    echo -e "\n${CYAN}═══ Rebuilding $service ═══${NC}\n"
    
    # Verify service exists in compose
    local compose_service="${service#homelab-}"
    if ! compose config --services 2>/dev/null | grep -q "^${compose_service}$"; then
        echo -e "${RED}✗ Service not found in docker-compose.yml${NC}"
        return 1
    fi
    
    # Rebuild
    echo "Building $compose_service..."
    compose build --no-cache "$compose_service"
    
    if [ $? -eq 0 ]; then
        echo ""
        echo "Recreating container..."
        compose up -d --force-recreate "$compose_service"
        
        echo ""
        echo -e "${GREEN}✅ Rebuild completed${NC}"
        echo "Check logs: ./homelab logs $service"
    else
        echo -e "\n${RED}✗ Rebuild failed${NC}"
        return 1
    fi
}

# ============================================
# CLEAN COMMAND - Cleanup Old Resources
# ============================================
clean() {
    echo -e "\n${CYAN}═══ Cleanup ═══${NC}\n"
    
    local cleaned=0
    
    # 1. Old log files
    echo -e "${CYAN}[1/4] Cleaning old logs${NC}"
    local log_dirs=("$PROJECT_ROOT/logs" "$PROJECT_ROOT/services/dashboard/logs" "$PROJECT_ROOT/services/discord-bot/logs" "$PROJECT_ROOT/services/stream-bot/logs")
    
    for dir in "${log_dirs[@]}"; do
        if [ -d "$dir" ]; then
            # Keep logs from last 7 days, delete older
            local deleted=$(find "$dir" -name "*.log" -type f -mtime +7 -delete -print 2>/dev/null | wc -l)
            if [ "$deleted" -gt 0 ]; then
                echo "  Removed $deleted log file(s) from $(basename $dir)"
                ((cleaned++))
            fi
        fi
    done
    
    if [ $cleaned -eq 0 ]; then
        echo "  No old logs to remove"
    fi
    
    # 2. Old backups
    echo -e "\n${CYAN}[2/4] Cleaning old backups${NC}"
    local backup_dir="$PROJECT_ROOT/backups"
    if [ -d "$backup_dir" ]; then
        cd "$backup_dir"
        # Keep last 10 backups
        local old_backups=$(ls -t homelab-backup-*.sql 2>/dev/null | tail -n +11)
        if [ -n "$old_backups" ]; then
            echo "$old_backups" | xargs rm -f
            local count=$(echo "$old_backups" | wc -l)
            echo "  Removed $count old backup(s)"
        else
            echo "  No old backups to remove"
        fi
    else
        echo "  No backup directory found"
    fi
    
    # 3. Unused Docker images
    echo -e "\n${CYAN}[3/4] Cleaning unused Docker images${NC}"
    docker image prune -f | grep -E "^(Total|Deleted)" || echo "  No unused images"
    
    # 4. Stopped containers
    echo -e "\n${CYAN}[4/4] Cleaning stopped containers${NC}"
    docker container prune -f | grep -E "^(Total|Deleted)" || echo "  No stopped containers"
    
    echo ""
    echo -e "${GREEN}✅ Cleanup completed${NC}"
}

# ============================================
# DB-SHELL COMMAND - PostgreSQL Shell Access
# ============================================
db_shell() {
    local database="${1:-postgres}"
    
    echo -e "${CYAN}═══ PostgreSQL Shell ═══${NC}\n"
    
    if ! is_running "homelab-postgres"; then
        echo -e "${RED}✗ PostgreSQL container not running${NC}"
        return 1
    fi
    
    echo "Connecting to database: $database"
    echo "Type '\q' or Ctrl+D to exit"
    echo ""
    
    docker exec -it homelab-postgres psql -U postgres -d "$database"
}

# ============================================
# TEST COMMAND - Integration Tests
# ============================================
test_services() {
    echo -e "\n${CYAN}═══ Integration Tests ═══${NC}\n"
    
    local tests_passed=0
    local tests_failed=0
    
    # Test 1: Database Connectivity
    echo -e "${CYAN}[1/6] Database Connectivity${NC}"
    if docker exec homelab-postgres psql -U postgres -c "SELECT 1" &>/dev/null; then
        echo -e "  ${GREEN}✓ PASS${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL${NC}"
        ((tests_failed++))
    fi
    
    # Test 2: Dashboard API
    echo -e "\n${CYAN}[2/6] Dashboard API${NC}"
    local dash_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ 2>/dev/null || echo "000")
    if [ "$dash_status" = "200" ] || [ "$dash_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $dash_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL (HTTP $dash_status)${NC}"
        ((tests_failed++))
    fi
    
    # Test 3: Discord Bot
    echo -e "\n${CYAN}[3/6] Discord Bot${NC}"
    local discord_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:4000/ 2>/dev/null || echo "000")
    if [ "$discord_status" = "200" ] || [ "$discord_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $discord_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${YELLOW}⚠ SKIP (HTTP $discord_status)${NC} - Service may not have /health endpoint"
        ((tests_passed++))  # Don't fail on this
    fi
    
    # Test 4: Stream Bot
    echo -e "\n${CYAN}[4/6] Stream Bot${NC}"
    local stream_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/ 2>/dev/null || echo "000")
    if [ "$stream_status" = "200" ] || [ "$stream_status" = "302" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $stream_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${YELLOW}⚠ SKIP (HTTP $stream_status)${NC} - Service may not have /health endpoint"
        ((tests_passed++))  # Don't fail on this
    fi
    
    # Test 5: Redis Connection
    echo -e "\n${CYAN}[5/6] Redis Connection${NC}"
    if docker exec homelab-redis redis-cli ping 2>/dev/null | grep -q "PONG"; then
        echo -e "  ${GREEN}✓ PASS${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL${NC}"
        ((tests_failed++))
    fi
    
    # Test 6: MinIO Health
    echo -e "\n${CYAN}[6/6] MinIO Health${NC}"
    local minio_status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9000/minio/health/live 2>/dev/null || echo "000")
    if [ "$minio_status" = "200" ]; then
        echo -e "  ${GREEN}✓ PASS (HTTP $minio_status)${NC}"
        ((tests_passed++))
    else
        echo -e "  ${RED}✗ FAIL (HTTP $minio_status)${NC}"
        ((tests_failed++))
    fi
    
    # Summary
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Results: $tests_passed passed, $tests_failed failed"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    if [ $tests_failed -eq 0 ]; then
        echo -e "${GREEN}✅ All tests passed!${NC}"
        return 0
    else
        echo -e "${RED}⚠ Some tests failed${NC}"
        return 1
    fi
}

# ============================================
# CONFIG MANAGEMENT COMMANDS
# ============================================

config_generate() {
    local env=$1
    local host=$2
    
    if [ -z "$env" ] || [ -z "$host" ]; then
        echo -e "${RED}Usage: ./homelab config generate <env> <host>${NC}"
        echo "Examples:"
        echo "  ./homelab config generate dev localhost"
        echo "  ./homelab config generate prod evindrake.net"
        exit 1
    fi
    
    echo -e "${CYAN}═══ Generating Configuration ═══${NC}\n"
    python3 "$PROJECT_ROOT/config/scripts/generate-config.py" --env "$env" --host "$host"
}

config_validate() {
    local env=$1
    local host=$2
    
    if [ -z "$env" ] || [ -z "$host" ]; then
        echo -e "${RED}Usage: ./homelab config validate <env> <host>${NC}"
        echo "Examples:"
        echo "  ./homelab config validate dev localhost"
        echo "  ./homelab config validate prod evindrake.net"
        exit 1
    fi
    
    echo -e "${CYAN}═══ Validating Configuration ═══${NC}\n"
    python3 "$PROJECT_ROOT/config/scripts/validate-config.py" --env "$env" --host "$host"
}

config_encrypt() {
    echo -e "${CYAN}═══ Encrypting Secrets ═══${NC}\n"
    "$PROJECT_ROOT/config/scripts/encrypt-secrets.sh"
}

# ============================================
# MODULAR DEPLOYMENT COMMANDS (Phase 2)
# ============================================

# Modular compose command
modular_compose() {
    local compose_files="$1"
    shift
    
    # Export DEPLOYMENT_PATH so docker-compose can use it in env_file directives
    export DEPLOYMENT_PATH
    
    docker compose \
        --project-directory "$PROJECT_ROOT" \
        --env-file "$ENV_FILE" \
        $compose_files \
        "$@"
}

# Validate required .env files for a service
validate_service_env() {
    local service_id=$1
    local missing=()
    
    # Check main .env
    if [ ! -f "${DEPLOYMENT_PATH}/.env" ]; then
        missing+=(".env")
    fi
    
    # Check service-specific .env if it should exist
    local service_env="${DEPLOYMENT_PATH}/.env.${service_id}"
    if [ -f "$service_env" ]; then
        # Service has dedicated config, all good
        :
    fi
    
    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${RED}ERROR: Missing required .env files:${NC}"
        for file in "${missing[@]}"; do
            echo "  - ${DEPLOYMENT_PATH}/$file"
        done
        echo ""
        echo "Generate Phase 1 configs first:"
        echo "  python3 config/scripts/generate-config.py prod evindrake_net"
        return 1
    fi
    
    return 0
}

# Get service group from services.yaml
get_service_group() {
    local service=$1
    local catalog="$PROJECT_ROOT/orchestration/services.yaml"
    
    if [ ! -f "$catalog" ]; then
        echo ""
        return
    fi
    
    # Simple grep-based parsing (fallback if yq not available)
    grep -A 50 "^  $service:" "$catalog" 2>/dev/null | grep "group:" | head -1 | awk '{print $2}' || echo ""
}

# Get services in a group
get_group_services() {
    local group=$1
    local catalog="$PROJECT_ROOT/orchestration/services.yaml"
    
    if [ ! -f "$catalog" ]; then
        echo ""
        return
    fi
    
    # Extract services list from group
    grep -A 5 "^  $group:" "$catalog" 2>/dev/null | grep "services:" | sed 's/.*services: \[//' | sed 's/\]//' | tr ',' ' ' || echo ""
}

# Deploy service or group (Phase 2: Dynamic from services.yaml)
deploy_service() {
    local target=$1
    
    if [ -z "$target" ]; then
        echo -e "${RED}Usage: ./homelab deploy <service|group>${NC}"
        echo ""
        echo "Examples:"
        echo "  ./homelab deploy dashboard      # Deploy single service"
        echo "  ./homelab deploy bots           # Deploy service group"
        echo "  ./homelab deploy core           # Deploy core infrastructure"
        echo ""
        echo "Run './homelab services list' to see available services and groups"
        return 1
    fi
    
    local catalog="$PROJECT_ROOT/orchestration/service_catalog.py"
    local orchestration="$PROJECT_ROOT/orchestration"
    
    if [ ! -f "$catalog" ]; then
        echo -e "${RED}ERROR: service_catalog.py not found${NC}"
        return 1
    fi
    
    echo -e "${CYAN}═══ Deploying: $target ═══${NC}\n"
    
    # Check if target is a group
    local group_services=$(python3 "$catalog" group "$target" 2>/dev/null)
    
    if [ -n "$group_services" ]; then
        # It's a group - deploy all services in the group
        echo "Deploying group: $target"
        echo "Services: $group_services"
        echo ""
        
        # Get all services with dependencies
        local services_to_deploy=$(python3 "$catalog" order $group_services 2>/dev/null)
        
        if [ -z "$services_to_deploy" ]; then
            echo -e "${RED}ERROR: Failed to resolve dependencies for group $target${NC}"
            return 1
        fi
        
        echo "Deployment order: $services_to_deploy"
        echo ""
        
        # Build compose file list (unique files only)
        local compose_files_args=""
        local seen_files=()
        
        for svc in $services_to_deploy; do
            # Get compose files for this service
            local svc_files=$(python3 "$catalog" compose "$svc" 2>/dev/null)
            
            for file in $svc_files; do
                # Add to list if not already seen
                if [[ ! " ${seen_files[@]} " =~ " ${file} " ]]; then
                    seen_files+=("$file")
                    compose_files_args="$compose_files_args -f $file"
                fi
            done
        done
        
        # Validate env files
        for svc in $services_to_deploy; do
            validate_service_env "$svc" || return 1
        done
        
        # Deploy
        modular_compose "$compose_files_args" up -d
        
    else
        # Check if it's a single service
        local service_info=$(python3 "$catalog" get "$target" 2>/dev/null)
        
        if [ -z "$service_info" ] || [ "$service_info" = "null" ]; then
            echo -e "${RED}Unknown service or group: $target${NC}"
            echo "Use './homelab services list' to see available options"
            return 1
        fi
        
        echo "Deploying service: $target"
        
        # Get dependencies and deployment order
        local all_services=$(python3 "$catalog" order "$target" 2>/dev/null)
        
        if [ -z "$all_services" ]; then
            echo -e "${RED}ERROR: Failed to resolve dependencies for $target${NC}"
            return 1
        fi
        
        echo "With dependencies: $all_services"
        echo ""
        
        # Build compose file list
        local compose_files_args=""
        local seen_files=()
        
        for svc in $all_services; do
            local svc_files=$(python3 "$catalog" compose "$svc" 2>/dev/null)
            
            for file in $svc_files; do
                if [[ ! " ${seen_files[@]} " =~ " ${file} " ]]; then
                    seen_files+=("$file")
                    compose_files_args="$compose_files_args -f $file"
                fi
            done
        done
        
        # Validate env files
        for svc in $all_services; do
            validate_service_env "$svc" || return 1
        done
        
        # Deploy
        modular_compose "$compose_files_args" up -d
    fi
    
    echo ""
    echo -e "${GREEN}✓ Deployment complete${NC}"
    echo "Check status: ./homelab status"
}

# Undeploy service or group (Phase 2: Dynamic from services.yaml)
undeploy_service() {
    local target=$1
    
    if [ -z "$target" ]; then
        echo -e "${RED}Usage: ./homelab undeploy <service|group>${NC}"
        return 1
    fi
    
    local catalog="$PROJECT_ROOT/orchestration/service_catalog.py"
    
    if [ ! -f "$catalog" ]; then
        echo -e "${RED}ERROR: service_catalog.py not found${NC}"
        return 1
    fi
    
    echo -e "${CYAN}═══ Undeploying: $target ═══${NC}\n"
    
    # Check if target is a group
    local group_services=$(python3 "$catalog" group "$target" 2>/dev/null)
    
    if [ -n "$group_services" ]; then
        # It's a group
        echo "Undeploying group: $target"
        echo "Services: $group_services"
        echo ""
        
        # Warn if undeploying core infrastructure
        if [ "$target" = "core" ]; then
            echo -e "${YELLOW}Warning: This will stop core infrastructure${NC}"
            echo "Other services may fail without core services."
            read -p "Continue? (y/N) " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Cancelled."
                return 0
            fi
        fi
        
        # Build compose file list for the group
        local compose_files_args=""
        local seen_files=()
        
        for svc in $group_services; do
            local svc_files=$(python3 "$catalog" compose "$svc" 2>/dev/null)
            
            for file in $svc_files; do
                if [[ ! " ${seen_files[@]} " =~ " ${file} " ]]; then
                    seen_files+=("$file")
                    compose_files_args="$compose_files_args -f $file"
                fi
            done
        done
        
        # Stop the services
        modular_compose "$compose_files_args" down
        
    else
        # Check if it's a single service
        local service_info=$(python3 "$catalog" get "$target" 2>/dev/null)
        
        if [ -z "$service_info" ] || [ "$service_info" = "null" ]; then
            # Try to stop by container name as fallback
            echo "Service not in catalog, trying container name..."
            docker stop "$target" 2>/dev/null && docker rm "$target" 2>/dev/null || {
                echo -e "${RED}Unknown service: $target${NC}"
                echo "Use './homelab services list' to see available options"
                return 1
            }
        else
            echo "Undeploying service: $target"
            
            # Get compose files for this service only (not dependencies)
            local compose_files_args=""
            local seen_files=()
            local svc_files=$(python3 "$catalog" compose "$target" 2>/dev/null)
            
            for file in $svc_files; do
                if [[ ! " ${seen_files[@]} " =~ " ${file} " ]]; then
                    seen_files+=("$file")
                    compose_files_args="$compose_files_args -f $file"
                fi
            done
            
            # Get container name from service
            local container_name=$(echo "$service_info" | python3 -c "import sys, json; data = json.load(sys.stdin); print(data.get('container_name', ''))" 2>/dev/null)
            
            if [ -n "$container_name" ]; then
                # Stop specific container
                docker stop "$container_name" 2>/dev/null && docker rm "$container_name" 2>/dev/null
            else
                # Fallback to compose down
                modular_compose "$compose_files_args" down
            fi
        fi
    fi
    
    echo -e "${GREEN}✓ Undeploy complete${NC}"
}

# Services management
services_cmd() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list|ls)
            echo -e "${CYAN}═══ Available Services & Groups ═══${NC}\n"
            echo -e "${GREEN}Service Groups:${NC}"
            echo "  core          - Core infrastructure (postgres, redis, minio, caddy)"
            echo "  bots          - Discord & Stream bots"
            echo "  web           - Web applications (n8n, homeassistant, static sites)"
            echo "  automation    - Background workers (celery)"
            echo "  development   - Dev tools (vnc-desktop, code-server)"
            echo ""
            echo -e "${GREEN}Individual Services:${NC}"
            echo "  dashboard     - Homelab management dashboard"
            echo "  discord-bot   - Discord ticket management bot"
            echo "  stream-bot    - Twitch/YouTube streaming bot"
            echo "  celery-worker - Background task processor"
            echo "  n8n           - Workflow automation"
            echo "  homeassistant - Smart home hub"
            echo "  vnc-desktop   - Remote desktop"
            echo "  code-server   - VS Code in browser"
            echo ""
            echo "Usage:"
            echo "  ./homelab deploy <service|group>"
            echo "  ./homelab undeploy <service|group>"
            ;;
        deps|dependencies)
            local target=$2
            if [ -z "$target" ]; then
                echo -e "${RED}Usage: ./homelab services deps <service>${NC}"
                return 1
            fi
            
            echo -e "${CYAN}═══ Dependencies for: $target ═══${NC}\n"
            case "$target" in
                dashboard)
                    echo "Required: postgres, redis, minio"
                    echo "Optional: homeassistant"
                    ;;
                discord-bot)
                    echo "Required: postgres"
                    ;;
                stream-bot)
                    echo "Required: postgres"
                    ;;
                celery-worker)
                    echo "Required: postgres, redis"
                    ;;
                *)
                    echo "No dependencies or unknown service"
                    ;;
            esac
            ;;
        catalog)
            if [ -f "$PROJECT_ROOT/orchestration/services.yaml" ]; then
                cat "$PROJECT_ROOT/orchestration/services.yaml"
            else
                echo -e "${RED}Service catalog not found${NC}"
            fi
            ;;
        discover)
            echo -e "\n${CYAN}═══ Discovered Services (Consul) ═══${NC}\n"
            
            if docker ps --format "{{.Names}}" | grep -q "^consul-server$"; then
                if command -v jq &> /dev/null; then
                    curl -s http://localhost:8500/v1/catalog/services 2>/dev/null | jq -r 'to_entries[] | "\(.key) (tags: \(.value | join(", ")))"' || echo "No services registered"
                else
                    curl -s http://localhost:8500/v1/catalog/services 2>/dev/null || echo "No services registered"
                fi
            else
                echo -e "${YELLOW}⚠ Consul not running${NC}"
                echo "Start Consul: docker compose -f orchestration/compose.consul.yml up -d"
            fi
            ;;
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: ./homelab services [list|deps|catalog|discover]"
            return 1
            ;;
    esac
}

# ============================================
# ROUTES COMMAND - Show Traefik Routes
# ============================================
routes_cmd() {
    local subcmd="${1:-list}"
    
    case "$subcmd" in
        list)
            echo -e "\n${CYAN}═══ Traefik Routes ═══${NC}\n"
            
            if docker ps --format "{{.Names}}" | grep -q "^traefik$"; then
                echo "Fetching routes from Traefik API..."
                echo ""
                
                if command -v jq &> /dev/null; then
                    echo -e "${CYAN}HTTP Routers:${NC}"
                    curl -s http://localhost:8080/api/http/routers 2>/dev/null | jq -r '.[] | "  \(.name): \(.rule) -> \(.service)"' || echo "  No HTTP routers"
                    
                    echo ""
                    echo -e "${CYAN}Services:${NC}"
                    curl -s http://localhost:8080/api/http/services 2>/dev/null | jq -r '.[] | "  \(.name): \(.loadBalancer.servers[0].url // "no backend")"' || echo "  No services"
                else
                    echo "Install jq for formatted output: sudo apt install jq"
                    curl -s http://localhost:8080/api/http/routers 2>/dev/null || echo "No routes"
                fi
            else
                echo -e "${YELLOW}⚠ Traefik not running${NC}"
                echo "Start Traefik: docker compose -f orchestration/compose.traefik.yml up -d"
            fi
            ;;
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: ./homelab routes [list]"
            return 1
            ;;
    esac
}

# ============================================
# DATABASE COMMAND - Phase 4 Database Management
# ============================================
db_cmd() {
    local subcmd="${1:-status}"
    
    case "$subcmd" in
        status)
            echo -e "\n${CYAN}═══ Database Platform Status ═══${NC}\n"
            
            # PostgreSQL Status
            echo -e "${CYAN}[1/4] PostgreSQL Database${NC}"
            if is_running "homelab-postgres"; then
                if docker exec homelab-postgres pg_isready -U postgres &>/dev/null; then
                    echo -e "  ${GREEN}✓${NC} PostgreSQL responding"
                    
                    # List databases
                    echo -e "\n  ${CYAN}Databases:${NC}"
                    docker exec homelab-postgres psql -U postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -v "^$" | grep -v "template" | while read db; do
                        echo "    - $db"
                    done
                else
                    echo -e "  ${RED}✗${NC} PostgreSQL not responding"
                fi
            else
                echo -e "  ${RED}✗${NC} PostgreSQL container not running"
            fi
            
            # pgBouncer Status
            echo -e "\n${CYAN}[2/4] pgBouncer Connection Pooler${NC}"
            if is_running "homelab-pgbouncer"; then
                echo -e "  ${GREEN}✓${NC} pgBouncer running on port 6432"
                echo -e "  ${CYAN}Pool Stats:${NC}"
                docker exec homelab-pgbouncer psql -h localhost -p 6432 -U postgres -d pgbouncer -c "SHOW POOLS;" 2>/dev/null || echo "    Unable to fetch stats"
            else
                echo -e "  ${YELLOW}⚠${NC} pgBouncer not running (optional)"
            fi
            
            # pgBackRest Status
            echo -e "\n${CYAN}[3/4] pgBackRest Backup Service${NC}"
            if is_running "homelab-pgbackrest"; then
                echo -e "  ${GREEN}✓${NC} pgBackRest running"
                echo -e "  ${CYAN}Backup Info:${NC}"
                docker exec homelab-pgbackrest pgbackrest --stanza=homelab info 2>/dev/null || echo "    No backups yet"
            else
                echo -e "  ${YELLOW}⚠${NC} pgBackRest not running (optional)"
            fi
            
            # Backup Scheduler Status
            echo -e "\n${CYAN}[4/4] Backup Scheduler${NC}"
            if is_running "homelab-backup-scheduler"; then
                echo -e "  ${GREEN}✓${NC} Backup scheduler running"
                echo -e "  ${CYAN}Schedule:${NC}"
                echo "    Full backup: Daily at 2 AM"
                echo "    Incremental: Every hour"
            else
                echo -e "  ${YELLOW}⚠${NC} Backup scheduler not running (optional)"
            fi
            ;;
            
        backup)
            echo -e "\n${CYAN}═══ Manual Database Backup ═══${NC}\n"
            
            if ! is_running "homelab-pgbackrest"; then
                echo -e "${RED}✗ pgBackRest not running${NC}"
                echo "Start with: ./homelab deploy database"
                return 1
            fi
            
            local backup_type="${2:-full}"
            echo "Starting $backup_type backup..."
            docker exec homelab-pgbackrest pgbackrest --stanza=homelab --type=$backup_type backup
            
            if [ $? -eq 0 ]; then
                echo -e "\n${GREEN}✓ Backup completed successfully${NC}"
                echo ""
                ./homelab db list-backups
            else
                echo -e "\n${RED}✗ Backup failed${NC}"
                return 1
            fi
            ;;
            
        restore)
            local backup_id="$2"
            
            if [ -z "$backup_id" ]; then
                echo -e "${RED}Error: Backup ID required${NC}"
                echo "Usage: ./homelab db restore <backup-id>"
                echo ""
                echo "Available backups:"
                ./homelab db list-backups
                return 1
            fi
            
            echo -e "\n${RED}⚠ WARNING: This will restore the database!${NC}"
            echo "This will stop all services and restore from backup."
            read -p "Are you sure? (yes/no): " confirm
            
            if [ "$confirm" != "yes" ]; then
                echo "Restore cancelled"
                return 0
            fi
            
            echo -e "\n${CYAN}Stopping services...${NC}"
            compose down
            
            echo -e "${CYAN}Restoring database from $backup_id...${NC}"
            docker exec homelab-pgbackrest pgbackrest --stanza=homelab --set=$backup_id restore
            
            if [ $? -eq 0 ]; then
                echo -e "\n${GREEN}✓ Restore completed${NC}"
                echo "Restarting services..."
                ./homelab fix
            else
                echo -e "\n${RED}✗ Restore failed${NC}"
                return 1
            fi
            ;;
            
        list-backups)
            echo -e "\n${CYAN}═══ Available Backups ═══${NC}\n"
            
            if ! is_running "homelab-pgbackrest"; then
                echo -e "${YELLOW}⚠ pgBackRest not running${NC}"
                echo "No backups available"
                return 0
            fi
            
            docker exec homelab-pgbackrest pgbackrest --stanza=homelab info
            ;;
            
        migrate)
            local service="$2"
            
            if [ -z "$service" ]; then
                echo -e "${RED}Error: Service name required${NC}"
                echo "Usage: ./homelab db migrate <service>"
                echo ""
                echo "Available services:"
                echo "  - dashboard (Alembic migrations)"
                echo "  - discord-bot (Drizzle migrations)"
                echo "  - stream-bot (Drizzle migrations)"
                return 1
            fi
            
            echo -e "\n${CYAN}═══ Running Migrations for $service ═══${NC}\n"
            
            case "$service" in
                dashboard)
                    if is_running "homelab-dashboard"; then
                        docker exec homelab-dashboard alembic upgrade head
                    else
                        echo -e "${RED}✗ Dashboard not running${NC}"
                        return 1
                    fi
                    ;;
                discord-bot)
                    if is_running "discord-bot"; then
                        docker exec discord-bot npm run db:push
                    else
                        echo -e "${RED}✗ Discord bot not running${NC}"
                        return 1
                    fi
                    ;;
                stream-bot)
                    if is_running "stream-bot"; then
                        docker exec stream-bot npm run db:push
                    else
                        echo -e "${RED}✗ Stream bot not running${NC}"
                        return 1
                    fi
                    ;;
                *)
                    echo -e "${RED}Unknown service: $service${NC}"
                    return 1
                    ;;
            esac
            
            if [ $? -eq 0 ]; then
                echo -e "\n${GREEN}✓ Migrations completed${NC}"
            else
                echo -e "\n${RED}✗ Migrations failed${NC}"
                return 1
            fi
            ;;
            
        help|*)
            cat << 'EOF'
╔════════════════════════════════════════════════════════╗
║          DATABASE MANAGEMENT (Phase 4)                 ║
╚════════════════════════════════════════════════════════╝

COMMANDS:
  ./homelab db status                - Show database platform status
  ./homelab db backup [type]         - Trigger manual backup (full|incr|diff)
  ./homelab db restore <backup-id>   - Restore from backup
  ./homelab db list-backups          - List available backups
  ./homelab db migrate <service>     - Run migrations for service

EXAMPLES:
  ./homelab db status                      # Show database health
  ./homelab db backup full                 # Full backup now
  ./homelab db backup incr                 # Incremental backup
  ./homelab db list-backups                # List backups
  ./homelab db restore 20251123-120000F    # Restore from backup
  ./homelab db migrate dashboard           # Run dashboard migrations
  ./homelab db migrate discord-bot         # Run Discord bot migrations

FEATURES:
  - pgBouncer: Connection pooling on port 6432
  - pgBackRest: Automated backups to MinIO
  - WAL Archiving: Point-in-time recovery
  - Automated Schedules: Daily full + hourly incremental

See orchestration/PHASE4_DATABASE_UPGRADE.md for details.
EOF
            ;;
    esac
}

# ============================================
# NETWORK COMMAND - Tailscale Network Info
# ============================================
network_cmd() {
    local subcmd="${1:-status}"
    
    case "$subcmd" in
        status)
            echo -e "\n${CYAN}═══ Network Status ═══${NC}\n"
            
            if command -v tailscale &> /dev/null; then
                echo -e "${CYAN}Tailscale Status:${NC}"
                tailscale status 2>/dev/null || echo "Not connected"
            elif docker ps --format "{{.Names}}" | grep -q "^tailscale$"; then
                echo -e "${CYAN}Tailscale Status (Container):${NC}"
                docker exec tailscale tailscale status 2>/dev/null || echo "Not connected"
            else
                echo -e "${YELLOW}⚠ Tailscale not installed${NC}"
                echo "Install: curl -fsSL https://tailscale.com/install.sh | sh"
                echo "Or see: orchestration/TAILSCALE_SETUP.md"
            fi
            ;;
        peers)
            echo -e "\n${CYAN}═══ Tailscale Network Peers ═══${NC}\n"
            
            if command -v tailscale &> /dev/null; then
                tailscale status 2>/dev/null | grep -v "^#" || echo "No peers"
            elif docker ps --format "{{.Names}}" | grep -q "^tailscale$"; then
                docker exec tailscale tailscale status 2>/dev/null | grep -v "^#" || echo "No peers"
            else
                echo -e "${YELLOW}⚠ Tailscale not installed${NC}"
            fi
            ;;
        routes)
            echo -e "\n${CYAN}═══ Tailscale Routes ═══${NC}\n"
            
            if command -v tailscale &> /dev/null; then
                echo -e "${CYAN}Advertised Routes:${NC}"
                tailscale status --json 2>/dev/null | grep -o '"AdvertiseRoutes":\[.*\]' || echo "No routes advertised"
            elif docker ps --format "{{.Names}}" | grep -q "^tailscale$"; then
                docker exec tailscale tailscale status --json 2>/dev/null | grep -o '"AdvertiseRoutes":\[.*\]' || echo "No routes advertised"
            else
                echo -e "${YELLOW}⚠ Tailscale not installed${NC}"
            fi
            ;;
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: ./homelab network [status|peers|routes]"
            return 1
            ;;
    esac
}

config_help() {
    cat << 'EOF'
╔════════════════════════════════════════════════════════╗
║         CONFIGURATION MANAGEMENT (SOPS + Age)          ║
╚════════════════════════════════════════════════════════╝

COMMANDS:
  ./homelab config generate <env> <host>  - Generate configs
  ./homelab config validate <env> <host>  - Validate configs
  ./homelab config encrypt                - Encrypt secrets

EXAMPLES:
  # Development
  ./homelab config generate dev localhost
  ./homelab config validate dev localhost

  # Production
  ./homelab config generate prod evindrake.net
  ./homelab config validate prod evindrake.net
  ./homelab config generate prod rig-city.com

  # Encrypt secrets after editing
  sops config/secrets/base.enc.yaml  # Edit secrets
  ./homelab config encrypt           # Re-encrypt

WORKFLOW:
  1. Edit secrets: sops config/secrets/base.enc.yaml
  2. Generate config: ./homelab config generate prod evindrake.net
  3. Validate: ./homelab config validate prod evindrake.net
  4. Deploy: Copy deployment/prod/evindrake_net/.env to server

See config/README.md for complete documentation.
EOF
}

# ============================================
# MAIN
# ============================================
case "${1:-help}" in
    fix|start)
        fix
        ;;
    status)
        status
        ;;
    logs)
        shift
        logs "$@"
        ;;
    debug)
        debug
        ;;
    health)
        health
        ;;
    validate-env)
        validate_env
        ;;
    backup)
        backup
        ;;
    restore)
        shift
        restore "$@"
        ;;
    update)
        update
        ;;
    rebuild)
        shift
        rebuild "$@"
        ;;
    clean)
        clean
        ;;
    db-shell)
        shift
        db_shell "$@"
        ;;
    test)
        test_services
        ;;
    deploy)
        shift
        deploy_service "$@"
        ;;
    undeploy)
        shift
        undeploy_service "$@"
        ;;
    services)
        shift
        services_cmd "$@"
        ;;
    routes)
        shift
        routes_cmd "$@"
        ;;
    network)
        shift
        network_cmd "$@"
        ;;
    db)
        shift
        db_cmd "$@"
        ;;
    config)
        shift
        case "${1:-help}" in
            generate)
                shift
                config_generate "$@"
                ;;
            validate)
                shift
                config_validate "$@"
                ;;
            encrypt)
                config_encrypt
                ;;
            *)
                config_help
                ;;
        esac
        ;;
    restart)
        echo "Restarting all services..."
        compose restart
        ;;
    stop)
        compose down
        echo -e "${GREEN}✓ All services stopped${NC}"
        ;;
    help|*)
        cat << 'EOF'
╔════════════════════════════════════════════════════════╗
║           HOMELAB - Production-Ready Management        ║
╚════════════════════════════════════════════════════════╝

Usage: ./homelab [command]

CORE COMMANDS:
  fix              - Fix everything and start all services
  status           - Show which services are running
  logs [service]   - View logs (add service name for specific)
  restart          - Restart all services
  stop             - Stop everything

MODULAR DEPLOYMENT (Phase 2):
  deploy <target>       - Deploy service or group
  undeploy <target>     - Stop service or group
  services list         - List all available services & groups
  services deps <svc>   - Show service dependencies
  services catalog      - View full service catalog
  services discover     - Show services registered with Consul

SERVICE DISCOVERY (Phase 3):
  routes list           - Show Traefik routing configuration
  network status        - Show Tailscale network status
  network peers         - Show Tailscale network peers
  network routes        - Show Tailscale advertised routes

DATABASE MANAGEMENT (Phase 4):
  db status             - Show database platform status (postgres, pgbouncer, backups)
  db backup [type]      - Trigger manual backup (full, incremental, differential)
  db restore <id>       - Restore database from backup
  db list-backups       - List all available backups
  db migrate <service>  - Run migrations for specific service

HEALTH & DIAGNOSTICS:
  health           - Comprehensive health checks (DB, API, disk, memory)
  validate-env     - Check .env has all required variables
  debug            - Show detailed debugging info
  test             - Run integration tests on all services

OPERATIONS:
  backup           - Backup all databases to timestamped files
  restore <file>   - Restore from backup
  update           - Git pull and redeploy (for production)
  rebuild <svc>    - Rebuild and restart specific service
  clean            - Clean old logs, unused containers/images
  db-shell [db]    - Quick PostgreSQL shell access

CONFIGURATION MANAGEMENT:
  config generate <env> <host>  - Generate encrypted configs
  config validate <env> <host>  - Validate generated configs
  config encrypt                - Encrypt secrets with SOPS
  config help                   - Show config management help

EXAMPLES:
  ./homelab fix                    # Fix all issues
  ./homelab deploy dashboard       # Deploy just dashboard
  ./homelab deploy bots            # Deploy Discord + Stream bots
  ./homelab deploy core            # Deploy infrastructure only
  ./homelab undeploy discord-bot   # Stop Discord bot
  ./homelab services list          # List available services
  ./homelab services deps dashboard # Show dashboard dependencies
  ./homelab health                 # Run health checks
  ./homelab validate-env           # Check environment variables
  ./homelab backup                 # Backup databases
  ./homelab restore backup.sql     # Restore from backup
  ./homelab update                 # Update from git
  ./homelab rebuild discord-bot    # Rebuild specific service
  ./homelab clean                  # Cleanup old files
  ./homelab db-shell homelab_jarvis  # Access database
  ./homelab test                   # Run integration tests
  ./homelab logs homelab-dashboard # View dashboard logs

MODULAR ARCHITECTURE:
  Services are now modular - deploy only what you need!
  - core: postgres, redis, minio, caddy
  - bots: discord-bot, stream-bot
  - web: n8n, homeassistant, static sites
  - automation: celery-worker
  - development: vnc-desktop, code-server

  See orchestration/README.md for architecture details

DOCUMENTATION:
  See OPERATIONS_GUIDE.md for detailed procedures
  See orchestration/README.md for modular deployment guide

The key: This script uses ABSOLUTE PATHS so Docker finds
your .env file and configurations correctly.

Run on your Ubuntu server at: /home/evin/contain/HomeLabHub
EOF
        ;;
esac
